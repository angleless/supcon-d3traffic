import React, { Component } from 'react'
import PropTypes from 'prop-types'
import { pointLenth, segmentDividePoints, splitPoint, ang2rad, normalMovePoint, lineAnglePoint, intersectionPoint2 } from './geometry'
import { caclStreetInfos, streetBorderPath, SVGCoord, directions2Id, originDataInfos, reSizeWidthInfo } from './utils'
// import Device from './Device'
// 区划图的宽度，高度，人行横道的宽度和人行河道的宽度比例

import {
  WIDTH,
  HEIGHT,
  CROSS_WALK_WIDTH,
  CROSS_SCALE_WALK_WIDTH
} from './consts'
// 设备的弹窗层 // 包括（视频，线圈，卡口，符合设备，雷达等icon的选择）
import InnerAddDevice from './InnerAddDevice'
// 方向选择的弹出框包括（左转，右转，直行，掉头，左右掉头，左直右，左右，左直，左掉头，右直，右掉头，右掉头左等Icon选择）
import InnerAddDirections from './InnerAddDirections'
// plugin插件机制之后扩展业务用plugin去扩展组件的功能
import Plugin from './Plugin'
// 在道路交叉口有个中心信号灯的icon显示内容
import CenterLight from './CenterLight'
// 写好的一个设备弹出框，用户可以选择性用设备弹出框也可以用上面组件内部的设备弹出框
import AddDevice from './AddDevice'
// 写好的一个转向弹出框，用户可以选择性的用转向弹出框
import AddDirection from './AddDirection'
// 写好的一个中心信号灯的组件用户可以选择性的使用
import InnerCenterLight from './InnerCenterLight'
import * as d3 from 'd3'
// ramda内容，只有分割道路线用到，具体用法问大佬
import pipe from 'ramda/src/pipe'
import map from 'ramda/src/map'
import zip from 'ramda/src/zip'
// 一些的mock数据在传入数据为空时候进行调试开发
import mock from './mock'
// 渠化图的背景图片
import './Aspects.less'
import svgPanZoom from 'svg-pan-zoom'
const COLOR_LIST = ['#FA541C', '#FFA940', '#389E0D', '#1890FF', '#08979C', '#774DB2', '#004195', '#FFEC3D']
const NO_DATA_COLOR = '#c9c9c9'
class TrafficFlow extends Component {
  constructor (props) {
    super(props)
    this.flag = false
    this.x = 0
    this.dx = 0
    this.left = 0
    this.y = 0
    this.dy = 0
    this.top = 0
  }

  initialState = {
    svg: null, // svg => id 为 cb-aspects-svg 的dom元素
    coord: null, // 进行直角坐标系向svg坐标系转化的构造函数实例
    data: null, // 源数据
    left: 0, // 拖动渠化图的Left值
    top: 0, // 拖动渠化图的top值
    streetInfos: [], // 渠化图主要的数据结构，角度，车道信息，还有主要的坐标点，车道的开始点，连接点和结束点
    flowData: [],
    showAddModal: false, // 是否展示设备的弹出框的控制变量
    showAddDirectionsModal: false, // 是否展示转向的弹出框的控制变量
    modalCoordinate: {}, // 弹出框的位置，{x, y}
    editRoadParams: {}, // 告诉弹出框组件具体的是哪个道路中的哪个车道的哪个（设备或方向）以下标下画线为格式： laneIndex_insIndex_deviceIndex
    showRoadName: false, // 是否在车道下面展示车道的名称
    isEdited: false, // 道路交叉口信号灯是否为编辑状态 为true是展示编辑状态的icon
    isEditOut: false, // 出口道（就是没有转向没有设备的没有停止线的车道）是否可以点击高亮
    isSelect: false, // 中间信号灯（是否为可以选择的状态true为红色，false为蓝色）
    showTip: false, // 是否展示移入某个设备或者增删车道按钮显示tip信息
    flag: false, // 控制是否移动渠化图已经结束的变量
    center: {}, // 渠化图的中心位置 x: 0.5 y: 0.5 代表在svg坐标下的x方向的50% y方向的50%得到的坐标点的位置
    contentScale: { x: 1, y: 1 }, // 缩放比例代表渠化图中的缩放的比例
    tipCoordinate: { x: 0, y: 0 } // he showtip一起的（移入某个设备或者增删车道按钮显示tip信息的在svg坐标系中的具体位置）
  }

  componentWillMount () {
    const { width, height, background } = this.props
    // 初始化state得到传入的width, height和背景
    const w = parseInt(width) ? parseInt(width) : WIDTH
    const h = parseInt(height) ? parseInt(height) : HEIGHT
    this.setState({
      ...this.initialState,
      background,
      w,
      h
    })
  }

  render () {
    // showLight 是否展示道路交叉口中的信号灯
    // center是渠化图在整个svg的位置 { x: 0.5， y: 0.5 }代表着svg的中心
    // addBtnBool 是否展示增删车道的按钮
    // width, height是props传入的宽高w， h实际的svg的宽高
    // 由于渠化图有拖动的效果所以中心点位置要校正通过top, left来进行矫正
    const { data: { center: { x, y } }, width, height, showLight, addBtnBool } = this.props
    const { background, isEdited, isSelect, showTip, showAddDirectionsModal, modalCoordinate, editRoadParams, showAddModal, w, h, top, left } = this.state
    return (
      <div id='cb-flow-container' ref={el => { this.refD3 = el }} style={{ width: width, height: height, transformOrigin: '0 0' }}>
        <svg id='#cb-flow-svg' className='cb-flow-svg-zoomPan' width='100%' height={h} viewBox='20 20 330 330' style={{ background: `${background || 'transparent'}`, w, h }}>
          {/* 一个背景图的pattern是整个渠化图的背景调用在下个元素fill='url(#ebebeb)' */}
          <pattern id='bg' width={24 / w} height={24 / h}>
            <rect x='0' y='0' width='24' height='24' fill='#ebebeb' />
            {/* <image xlinkHref={iconBg} width='24' height='24' /> */}
          </pattern>
          {/* 用rect矩形标签进行渲染背景，背景色是fill='url(#bg)' */}
          {/* <rect x='0' y='0' width={w} height={h} fill='url(#bg)' /> */}
          {/* 定义一个渐变背景通过fill =(url(#Gradient1))调用 */}
          <defs>
            <linearGradient id='Gradient1'>
              <stop stopColor='rgb(136,124,246)' offset='0%' />
              <stop stopColor='rgb(89,150,255)' offset='50%' />
            </linearGradient>
          </defs>
          <defs>
            <marker id='markerArrow' viewBox='0 0 80 70' markerWidth='12' markerHeight='10' refX='2' refY='5' orient='auto'>
              <path d='M0,0 L12,5 L0,10 L0,0' style={{ fill: 'red' }} />
            </marker>
          </defs>
          {/* 定义一个pattern关于绿波带的背景，主辅路中间有绿波带 */}
          <pattern id='grass' width='40%' height='6%' patternContentUnits='objectBoundingBox'>
            <image
              id='image0'
              width='1000'
              height='1000'
              x='0'
              y='0'
              href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAMK2lDQ1BpY2MAAHjalVd3VJN3F37e
              kYSEMBNRkBE2giiibNlbEJANLkISIBBCfElQcVtrK1gHKg4cddRdbR2g1IGodRbBbR0fDlSUWtTi
              Vr4/ErDjO+c7/Z2TN/c8v+c+97n3vCcnFzBKEqtUCtIYKFaqmeToMFFmVraI8wAESPBgAZFYUqoK
              TUqKB4Ce77+eV1dBAMAld7FKpcC/OyZSWakEIJIA5EpLJcUAsQ+gvSUqRg2wOgDYT1Sr1ADbGICQ
              yczKBtgOAIT52tgXgDBXG8cDEDKpyeEAOwfQ44vFTD5gqAAgKpPkqwHD+QA8lFK5EjA8BCBIUiCW
              AoYfAAwsLi6RAkYuAFxy/6ST/xfN3F5NsTi/N9b2AgDQi5CXqhTiyf9yHP//FCs0PTXsAfALmJhk
              AEKA2FdUEpcMgA8Qp5W5CYkATAHislwK6OKHBZqYNB3/jaQ0PBuAGUDypeKIOACWAGmnVCTE6/Cg
              PHlULABjgEyVq2NTtbmklClJ1umTk2SlkSk9sZgBdJwKTVFaqE5zbYEstkezvrwgNUPrk2wuk6cn
              ADAEyFulRSlxOs6T8oLwhB4Oo0lOA+AAUMhjopK1HMqhuLSnL8q/QB6boIvj1QWpMdpcapxEHJkC
              oB9AFcpKM+N7fEplEZHavqjZMmWazj9VpVKHJev4m1SKJB2fOiRTRCcDsAOoptKylJ7cTjWTqps/
              DZU6KVXrjRYWikckaT3QrohHOCIgggYi5KIEhZA3ddR1QKS7iYIYDPIhg7sO6cnIgBgMlBAjBeX4
              DUrIUNqbFwYxGMhQBiU+9qLapzvyIAaDMshQiiI8BINixEEBGTRgIIOyt1o6HoCB/B/VJSiBAiVg
              IP8nJjLqwdiR7Ah2DDuKPYC2oIPoADqeDqJD6CDak/al/Xp8feazHrJaWPdYV1itrBvj5bOZvzkX
              YSRaodFNRYbcP3dHO9GetBcdRgfSQbQfRLQZbQF3ehjtS4fSwXQA7UX7/cWrprfjz7PUaXE9uCS3
              LzeE6/J3B4auhl69KjIo/zILra/c3mmF9978vY/wP81PihLE/Z1JfU3tpU5Rx6gz1CGqDiLqKHWA
              Ok8dpur+9G48AIP83mrJkEGJIigg/0c9sa4mAxlKPXZ4tHt80N1BLZukBoDwEtVkRp5foBaFqlQK
              mShWKRk0UOTp4ekBZGZli7Q/LS/NQAAgzM5+xiY0AH4VAJH/GRPbAwcfAoJXnzH7FwB/EXC4WaJh
              yrQYDQAs8GAEIcxhDXu4wB2e8EYAQhCJEUhEKrIwDhIUoBgMJmIqZmEuKrEIy7AK67ARW/E99qAO
              h3AMP+McmnEFN9GKNjxFJ17hPUEQHMKAEBDmhA3hSLgRnoQvEUREEvFEMpFF5BD5hJLQEFOJL4hK
              oopYRawnthE/EgeJY8QZooW4Qdwl2okXxDuSIvmkkLQincjBpC8ZSsaRqeRYMp+cQJaTc8gF5Apy
              A7mTrCWPkefIK2Qr+ZTsokDpU2aULeVO+VLhVCKVTeVRDDWdqqCqqQ3ULqqeOkVdolqpDuotzaYF
              tIh2pwPoGDqNltAT6On0fHoVvZWupU/Ql+i7dCf9iWXAsmS5sfxZsaxMVj5rImsuq5q1mbWfdZJ1
              hdXGesVms83Yzmwfdgw7i13InsKez17D3s1uYLew77O7OByOOceNE8hJ5Ig5as5czkrOTs5RzkVO
              G+eNnr6ejZ6nXpRetp5Sb7Zetd52vSN6F/Ue6b3nGnMduf7cRK6UO5m7kLuJW8+9wG3jvueZ8Jx5
              gbxUXiFvFm8FbxfvJO8W76W+vr6dvp/+KH25/kz9Ffo/6J/Wv6v/lm/Kd+WH88fwNfwF/C38Bv4N
              /ksDAwMngxCDbAO1wQKDbQbHDe4YvDEUGA4yjDWUGs4wrDGsNbxo+MyIa+RoFGo0zqjcqNpor9EF
              ow5jrrGTcbix2Hi6cY3xQeNrxl0mApMhJokmxSbzTbabnDF5bMoxdTKNNJWazjHdaHrc9L6AEtgL
              wgUSwReCTYKTgjYhW+gsjBUWCiuF3wubhJ19TPsM65PeZ1Kfmj6H+7SaUWZOZrFmCrOFZnvMrpq9
              62vVN7SvrO+8vrv6Xuz7ul//fiH9ZP0q+u3ud6XfO3OReaR5kfli8zrz2xa0havFKIuJFmstTlp0
              9Bf2D+gv6V/Rf0//Xy1JS1fLZMsplhstz1t2WVlbRVuprFZaHbfqsDazDrEutF5qfcS63UZgE2Qj
              t1lqc9TmiaiPKFSkEK0QnRB12lraxthqbNfbNtm+t3O2S7Obbbfb7rY9z97XPs9+qX2jfaeDjcNI
              h6kOOxx+deQ6+joWOC53POX42snZKcPpK6c6p8fO/ZxjncuddzjfcjFwCXaZ4LLB5fIA9gDfAUUD
              1gxodiVdvVwLXGtcL7iRbt5ucrc1bi0DWQP9BioHbhh4zZ3vHupe5r7D/e4gs0Hxg2YPqhv0bLDD
              4OzBiwefGvzJw8tD4bHJ4+YQ0yEjhsweUj/khaerp8SzxvPyUIOhUUNnDD0w9Pkwt2GyYWuHXfcS
              eI30+sqr0eujt483473Lu93HwSfHZ7XPNV+hb5LvfN/Tfiy/ML8Zfof83vp7+6v99/j/HuAeUBSw
              PeDxcOfhsuGbht8PtAsUB64PbA0SBeUEfRvUGmwbLA7eEHwvxD5EGrI55FHogNDC0J2hz8I8wpiw
              /WGvw/3Dp4U3RFAR0REVEU2RppFpkasi70TZReVH7YjqjPaKnhLdEMOKiYtZHHMt1ipWErsttnOE
              z4hpI07E8eNS4lbF3Yt3jWfi60eSI0eMXDLyVoJjgjKhLhGJsYlLEm8nOSdNSPppFHtU0qiaUQ+T
              hyRPTT6VIkgZn7I95VVqWOrC1JtpLmmatMZ0o/Qx6dvSX2dEZFRltGYOzpyWeS7LIkuedSCbk52e
              vTm7a3Tk6GWj28Z4jZk75upY57GTxp4ZZzFOMe7weKPx4vF7c1g5GTnbcz6IE8UbxF25sbmrczsl
              4ZLlkqfSEOlSabssUFYle5QXmFeV9zg/MH9JfntBcEF1QYc8XL5K/rwwpnBd4euixKItRd2KDMXu
              Yr3inOKDSlNlkfJEiXXJpJIWlZtqrqp1gv+EZRM6mThmcylROrb0gFqoVqnPa1w0X2rulgWV1ZS9
              mZg+ce8kk0nKSecnu06eN/lReVT5d1PoKZIpjVNtp86aenda6LT104npudMbZ9jPmDOjbWb0zK2z
              eLOKZv0y22N21ew/vsj4on6O1ZyZc+5/Gf3ljrmGc5m5174K+Grd1/TX8q+b5g2dt3LepwppxdlK
              j8rqyg/zJfPPfjPkmxXfdC/IW9C00Hvh2kXsRcpFVxcHL95aZVJVXnV/ycgltUtFSyuW/rFs/LIz
              1cOq1y3nLdcsb10Rv+LASoeVi1Z+WFWw6kpNWM3u1Zar561+vUa65uLakLW71lmtq1z37lv5t9fX
              R6+v3eC0oXoje2PZxoeb0jed+s73u22bLTZXbv64RbmldWvy1hPbfLZt2265feEOcodmR/vOMTub
              v4/4/sAu913rd5vtrvwBP2h+ePJjzo9X98Ttadzru3fXPsd9q/cL9lfUErWTazvrCupaD2QdaDk4
              4mBjfUD9/p8G/bTlkO2hmsN9Di88wjsy50j30fKjXQ2qho5j+cfuN45vvHk88/jlE6NONJ2MO3n6
              56ifj58KPXX0dODpQ2f8zxw863u27pz3udrzXuf3/+L1y/4m76baCz4XDjT7Nde3DG85cjH44rFL
              EZd+vhx7+dyVhCstV9OuXr825lrrden1xzcUN57/Wvbr+5szb7FuVdw2vl19x/LOhv8M+M/uVu/W
              w3cj7p6/l3Lv5n3J/acPSh98aJvz0OBh9SObR9seez4+1B7V3vxk9JO2p6qn7zvm/mby2+pnLs/2
              /R7y+/nOzM6258zz7hfzX5q/3PLHsD8au5K67rwqfvX+dcUb8zdb3/q+PfUu492j9xM/cD6s+Djg
              Y/2nuE+3uou7u1ViRgwAoACQeXnAiy2AQRYgaAZ4o7W7GQCA0O6TgPY/yP+OtfsbAMAb2BICpM0E
              4huAtQ2A40yA3wAkAUgNATl0aO9Hd0rzhnpqtfgMwHrT3f3SCuDUAx+Z7u73a7q7P24CqBtAwwTt
              Tghod9BvBwFAc9uzf+xm/wUn93Ei44digAAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpg
              AAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAd3RF
              WHRSYXcgcHJvZmlsZSB0eXBlIDhiaW0ACjhiaW0KICAgICAgNDAKMzg0MjQ5NGQwNDA0MDAwMDAw
              MDAwMDAwMzg0MjQ5NGQwNDI1MDAwMDAwMDAwMDEwZDQxZDhjZDk4ZjAwYjIwNGU5ODAwOTk4CmVj
              Zjg0MjdlCqZTw44AAAAldEVYdFJhdyBwcm9maWxlIHR5cGUgaXB0YwAKaXB0YwogICAgICAgMArA
              1vxmAAADf0lEQVQ4ywXBSY8cNRgA0M/256VcVV3VPTM9mTAkQUhIOcApHBAnhMT/v+ZEcgiaSe+u
              xbvNe+SPfz4BlLZr7LIGtzLON8+D9/H85dT2HeHYd7uXr98p+kYjFen5/TvI8PLyYoxBkiotEGzJ
              uTadLjFdDsfJeQ6MM5ymOfjKVGGEN0Lo/cik8pdrq7lUG/bn37+zUk2wQ98v1kbvEKUSssSYUljX
              WXCqOy41pJpb/WDX+O/nz/McbAS2f9svwSPSpkEX1uiZIPTp/okJaWZfA5CSXIqMsgxwmg1CbVsp
              m347btnuhzHbSDkTA0GOjDESiRobOWw2cnj37sPxuwnOgOA1FT9PV3PFnhdWk6/s7lkXUhvZFgrW
              LoSJ7JxQOrgluKJ7VWWwbmEgnEupoGKUIJSazW0iv/31cw2FClETIS20nMusSk2ZkZroTBcGWYMG
              IJVR3crL8eLrqrtNtYkN+zbFpLUc3+43cpzNpDm/TlMpOQW/mFsC0vUypJRjYIRqpQXjkzGtbpDT
              9nY+DxsxoFqus7lY+oB62yIQzlBdaKwshlowmKtzp/nN473iKLFJBfDx7q4TnCLebe9ns+ihUb0G
              ulAmYgBbckoZTOZaNFpr5NHVUmqKvmTCfvn4E1BolM4kny+H1c82RhDtoLch1qEdJYLNYduP43hn
              fZCcEMlCSJxRerOTK4V18jrZyGvh4vj127bZS7nF2mArdvv7FuT1Mk+nE9ToEY6nUy0JiqMAFCUK
              hgwzyaiA7d//WKovZeaQgrE11KfnD4SHlBLjbPLXEOJkwm2i7OOnX8euBZo7LkchGRAuePSuQR6c
              N9djFlwqiCFH8MPuvh92w6g4ZxUrdkpQrOY62eCQSkXZ4uzxcBGRZRY9gbak19dDSpl3uwClVZg8
              gqgNVPbm7c4FezgersskG6aU7NoHJbp5WSrF8WHnnK3Vd8NWik2pkJO/Hm7LtCitEIVcnVVKE9Jk
              3lySa7JC1Uwvx61UWAmhEGOM1ga/atVEIH6tx8NSHGKp5OHpMcVbdBalNjN7tWY1Nw6sFjLIzaZn
              3/7zhSTAYnwIU5ZSvn98Oh3PKAcauS+Vh2QmE7hQrehkX3jKWcyuaGJj3w+362xmL5FRVoZWIeXm
              Ymhcw/n8vdIYE8l20YrkcFujhYHq7fawnl/NaV7cPLkwuVKgaeRc7H/HL91O/Q9HyzpLvu+gmgAA
              AGxlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQA
              AAABAAAATgAAAAAAAACQAAAAAQAAAJAAAAABAAKgAgAEAAAAAQAAABSgAwAEAAAAAQAAABQAAAAA
              2PcZ+wAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMC0wNC0yM1QxMTozMDoyOSswODowMNNye5YAAAAl
              dEVYdGRhdGU6bW9kaWZ5ADIwMjAtMDQtMjNUMTE6MzA6MjkrMDg6MDCiL8MqAAAAEnRFWHRleGlm
              OkV4aWZPZmZzZXQANzjJ1HsnAAAAF3RFWHRleGlmOlBpeGVsWERpbWVuc2lvbgAyMH+5N3oAAAAX
              dEVYdGV4aWY6UGl4ZWxZRGltZW5zaW9uADIwoi/u/wAAACh0RVh0aWNjOmNvcHlyaWdodABDb3B5
              cmlnaHQgQXBwbGUgSW5jLiwgMjAyMAq63rAAAAAXdEVYdGljYzpkZXNjcmlwdGlvbgBEaXNwbGF5
              FxuVuAAAAABJRU5ErkJggg=='
            />
          </pattern>
          {/* 所有的icon都放在symbol里面，包括转向的icon,设备的icon和自定义的icon 引用通过href进行引入 */}
          <g id='cb-aspects-symbols'>
            <symbol width='24' height='24' id='LEFT_STRAIGHT_RIGHT_BACK' viewBox='0 0 1024 1024'>
              <path d='M518.276741 0L597.333333 408.187259h-51.607703L545.716148 546.133333l136.154074-120.272592V293.925926L758.518519 497.701926 681.860741 675.081481V557.653333L545.716148 673.943704V1014.518519h-1.34637v0.142222H483.555556V1014.518519h-0.12326v-2.740149h-3.811555V708.41837c-13.539556-19.560296-32.95763-29.345185-58.263704-29.345185-34.721185 0-50.669037 22.584889-47.853037 67.745185l0.208593 2.910815v49.464889h57.144888L348.16 1011.787852 265.481481 799.184593h57.154371V701.696c4.721778-13.293037 10.477037-24.841481 17.256296-34.645333L265.481481 494.838519l76.657778-203.776v131.925333l141.293037 124.823704V408.187259H436.148148L518.276741 0zM342.139259 554.780444v109.160297C361.035852 638.501926 387.441778 625.777778 421.357037 625.777778c1.336889 0 2.673778 0.018963 3.982222 0.06637l-83.2-71.063704z' />
            </symbol>
            <symbol id='NONE' width='40' fillOpacity='0'>
              <path d='M22.7663551,46.278417 L22.7663551,90 L22.3069868,90 L17.271028,90 L17.271028,46.278417 L6.34682724,34.7099459 L6.34682724,49.0104037 L0,25.4898044 L6.34682724,0 L6.34682724,15.127757 L20.0186916,30.101755 L33.6905559,15.127757 L33.6905559,0 L40.0373832,25.4898044 L33.6905559,49.0104037 L33.6905559,34.7099459 L22.7663551,46.278417 Z' />
            </symbol>
            <symbol width='24' height='24' id='STRAIGHT' viewBox='0 0 1024 1024'>
              <path d='M 478.38 412.002 H 430.654 L 513.55 0 L 593.346 412.002 h -52.09 V 1024 h -62.8755 Z' />
            </symbol>
            <symbol id='LEFT' viewBox='0 0 1024 1024' width='24' height='24'>
              <path d='M 450.608 0 L 373.234 290.022 l 77.3742 267.609 V 394.919 l 138.766 137.159 V 1024 H 650.766 V 376.727 L 450.608 172.118 Z' />
            </symbol>
            <symbol id='FORBID-BACK' viewBox='0 0 1024 1024' width='24' height='24'>
              <path d='M405.74873 0L483.018868 17.697811 362.798692 512 483.018868 1006.302189 405.74873 1024 322.012579 679.697711 238.276428 1024 161.006289 1006.302189 281.226465 512 161.006289 17.697811 238.276428 0 322.012579 344.302289 405.74873 0z m301.249207 0c103.443321 0 152.170264 95.206239 152.170264 155.763925v864.912905H788.73761V242.282264c0-107.848453-27.242264-161.766239-81.733233-161.766239-54.484528 0-81.578667 53.917786-81.256654 161.766239v94.600855h70.082818l-108.969057 406.637485-100.313358-406.637485H554.827673V155.763925C554.827673 98.188075 603.554616 0 706.997937 0z' />
            </symbol>

            <symbol id='BACK' width='24' height='24' viewBox='0 0 1024 1024'>
              <path d='M 696.889 1024 V 125.819 C 660.414 41.9271 607.953 0 539.525 0 C 471.097 0 422.874 41.9366 394.875 125.819 v 212.158 H 327.111 l 99.5461 407.96 l 108.136 -407.96 h -69.5467 v -94.9096 c 4.95882 -62.0658 29.7244 -93.1081 74.2779 -93.1081 c 44.563 0 73.7185 31.0424 87.4667 93.1081 V 1024' />
            </symbol>
            <symbol id='RIGHT' width='24' height='24' viewBox='0 0 1024 1024'>
              <path d='M 571.277 0 L 645.981 290.022 l -74.7041 267.609 V 394.919 l -133.981 137.159 V 1024 H 378.019 V 376.727 l 193.258 -204.609 Z' />
            </symbol>
            <symbol id='STRAIGHT_RIGHT_BACK' viewBox='0 0 1024 1024' width='24' height='24'>
              <path d='M512.176 0l77.52 413.104h-48.544v133.712l135.264-127.52V251.232L744 460.24l-67.584 209.008v-153.52l-135.264 128.16V1024h-56.272V718.032c-12.896-21.76-31.92-32.624-57.12-32.624-33.6 0-48.656 23.776-45.152 71.312v49.92h54.176l-78.4 214.608L280 806.656h54.176v-98.4c17.072-51.088 48.256-76.64 93.6-76.64 23.536 0 42.592 7.632 57.12 22.848l-0.016-241.36H434.672L512.16 0z' />
            </symbol>
            <symbol id='RIGHT_BACK' viewBox='0 0 1024 1024' width='24' height='24'>
              <path d='M674.452645 0L751.483871 287.331097 674.452645 552.464516v-161.197419l-138.173935 135.894709v487.357936h-61.109678V688.194065c-9.529806-38.730323-28.787613-58.103742-57.806451-58.103742-29.844645 0-46.426839 20.513032-49.763097 61.539096v62.728258h46.592L341.751742 1024 275.059613 754.357677h45.402839v-140.238451c18.745806-55.444645 51.051355-83.15871 96.900129-83.15871 21.652645 0 40.910452 6.177032 57.806451 18.547613V373.248l199.283613-202.718968V0z' />
            </symbol>
            <symbol id='STRAIGHT_RIGHT' width='24' height='24' viewBox='0 0 1024 1024'>
              <path d='M 405.36 1024 V 413.103 H 354.093 L 433.238 0 l 79.1351 413.103 h -49.5731 v 337.413 L 600.906 614.41 v -168.051 L 669.907 718.733 l -69.0004 258.699 V 823.928 L 462.81 952.09 V 1024 Z' />
            </symbol>
            <symbol id='LEFT_STRAIGHT' width='24' height='24' viewBox='0 0 1024 1024'>
              <path d='M 615.414 1024 V 413.103 H 665.122 L 588.379 0 l -76.7426 413.103 h 48.0706 v 337.413 L 425.783 614.41 v -168.051 L 358.879 718.733 l 66.9045 258.699 V 823.928 l 133.924 128.163 V 1024 Z' />
            </symbol>
            <symbol id='LEFT_BACK' viewBox='0 0 1024 1024' width='24' height='24'>
              <path d='M451.176296 0v170.524444L649.481481 373.238519V1014.518519h-60.823703V674.778074c-10.391704-29.790815-28.254815-44.695704-53.570371-44.695704-29.705481 0-46.212741 20.517926-49.521777 61.534815v62.738963h46.364444L459.851852 1024 393.481481 754.346667h45.17926V614.115556C457.320296 558.677333 489.472 530.962963 535.087407 530.962963c19.882667 0 37.736296 5.262222 53.579852 15.796148v-19.607704L451.166815 391.262815v161.204148L374.518519 287.336296 451.176296 0z' />
            </symbol>
            <symbol id='LEFT_RIGHT_BACK' viewBox='0 0 1024 1024' width='24' height='24'>
              <path d='M478.504673 1024V580.368748c-14.068037-25.446879-32.289495-38.165533-54.673944-38.165533-29.810841 0-44.721047 22.56628-44.721047 67.708411V806.663178h53.640374l-77.613458 214.590205L277.53271 806.653607h53.640374V574.617121a238.63028 238.63028 0 0 1 10.24-30.557308L267.962617 290.021682 345.336822 0v206.101533L512 376.468336l166.663178-170.366803V0L756.037383 290.021682l-77.374205 267.608524V360.046056L545.495327 491.653981V1024h-66.990654zM345.336822 360.046056v175.285832c17.943925-37.179813 44.118131-55.764935 78.493907-55.764935 22.307888 0 40.538916 6.316262 54.683514 18.939215L478.504673 491.663551 345.336822 360.046056z' />
            </symbol>
            <symbol id='LEFT_STRAIGHT_BACK' viewBox='0 0 1024 1024' width='24' height='24'>
              <path d='M587.824 0L664 413.104h-49.344V1024H559.36V714.784c-12.608-19.584-30.656-29.376-54.128-29.376-33.04 0-47.84 23.776-44.4 71.312v49.92H514.08L437.04 1021.264 360 806.656h53.248v-98.4c16.768-51.088 47.424-76.64 91.984-76.64 22.064 0 40.112 6.944 54.128 20.8v-8.528l-132.944-128.16v153.52L360 460.24l66.416-209.008v168.064l132.944 127.52v-133.712H511.648L587.808 0z' />
            </symbol>
            <symbol id='LEFT_STRAIGHT_RIGHT' viewBox='0 0 1024 1024' width='24' height='24'>
              <path d='M483.146168 1024v-71.909682L349.22228 823.927626v153.504299L282.317757 718.761869 349.22228 446.349159v168.060411l133.923888 136.105869V413.102654h-48.070579L511.827738 0 512 0.957009l0.181832-0.957009 76.742579 413.102654h-48.070579v337.412785l133.923888-136.105869v-168.050841L741.682243 718.733159l-66.904523 258.698766V823.927626L540.853832 952.090318V1024z' />
            </symbol>
            <symbol id='RIGHT_BACK' viewBox='0 0 1024 1024' width='24' height='24'>
              <path d='M451.176296 0v170.524444L649.481481 373.238519V1014.518519h-60.823703V674.778074c-10.391704-29.790815-28.254815-44.695704-53.570371-44.695704-29.705481 0-46.212741 20.517926-49.521777 61.534815v62.738963h46.364444L459.851852 1024 393.481481 754.346667h45.17926V614.115556C457.320296 558.677333 489.472 530.962963 535.087407 530.962963c19.882667 0 37.736296 5.262222 53.579852 15.796148v-19.607704L451.166815 391.262815v161.204148L374.518519 287.336296 451.176296 0z' />
            </symbol>
            <symbol id='STRAIGHT_BACK' viewBox='0 0 1024 1024' width='24' height='24'>
              <path d='M589.302519 0L663.703704 408.187259h-48.57363V1014.518519h-58.624V684.73363l-3.982222 6.893037c-8.590222-39.973926-26.548148-60.472889-53.883259-61.496889l-2.180741-0.047408c-28.558222 0-44.439704 20.517926-47.616 61.534815v62.738963h44.581926L424.106667 1024 360.296296 754.346667h43.434667V614.115556C421.679407 558.677333 452.589037 530.962963 496.459852 530.962963c22.784 0 42.799407 7.471407 60.055704 22.423704l-0.009482-145.199408H512L589.302519 0z' />
            </symbol>
            <symbol id='LEFT_RIGHT' width='24' height='24' viewBox='0 0 1024 1024'>
              <path d='M 478.505 1024 V 526.547 L 345.337 394.919 v 162.711 L 267.963 290.022 L 345.337 0 v 172.118 L 512 342.485 l 166.663 -170.367 V 0 L 756.037 290.022 l -77.3742 267.609 V 394.919 L 545.495 526.547 V 1024 h -66.9907 Z' />
            </symbol>
            <symbol id='GANTRY' viewBox='0 0 1024 1024' version='1.1' width='24' height='24'>
              <path d='M256 159.288889l-130.844444 227.555555 540.444444 312.888889 130.844444-227.555555-540.444444-312.888889z m28.444444-56.888889l540.444445 312.888889c34.133333 17.066667 39.822222 56.888889 22.755555 91.022222l-130.844444 227.555556c-17.066667 34.133333-56.888889 39.822222-91.022222 22.755555L91.022222 443.733333c-34.133333-17.066667-45.511111-56.888889-22.755555-91.022222l130.844444-227.555555c17.066667-34.133333 56.888889-39.822222 85.333333-22.755556z m620.088889 455.111111c11.377778-17.066667 28.444444-22.755556 45.511111-11.377778 17.066667 11.377778 22.755556 28.444444 11.377778 45.511111l-113.777778 193.422223c-11.377778 17.066667-28.444444 22.755556-45.511111 11.377777-17.066667-11.377778-22.755556-28.444444-11.377777-45.511111l113.777777-193.422222zM227.555556 625.777778c11.377778-17.066667 28.444444-22.755556 45.511111-11.377778l290.133333 170.666667c17.066667 11.377778 22.755556 28.444444 11.377778 45.511111-5.688889 17.066667-28.444444 22.755556-39.822222 11.377778l-119.466667-68.266667-96.711111 164.977778H102.4c-17.066667 0-34.133333-17.066667-34.133333-34.133334s17.066667-34.133333 34.133333-34.133333H284.444444L358.4 739.555556l-119.466667-68.266667c-11.377778-5.688889-17.066667-22.755556-11.377777-45.511111z' />
            </symbol>
            <symbol id='CAMERA' viewBox='0 0 1024 1024' width='24' height='24'>
              <path d='M728.177778 307.2v56.888889h-455.111111v-56.888889h455.111111zM881.777778 227.555556H130.844444v221.866666h750.933334V227.555556z m-375.466667 358.4c39.822222 0 68.266667 28.444444 68.266667 68.266666s-28.444444 68.266667-68.266667 68.266667-68.266667-28.444444-68.266667-68.266667c0-34.133333 28.444444-68.266667 68.266667-68.266666zM796.444444 506.311111H210.488889C210.488889 665.6 341.333333 796.444444 500.622222 796.444444S796.444444 665.6 796.444444 506.311111zM881.777778 170.666667c28.444444 0 56.888889 22.755556 56.888889 56.888889v221.866666c0 28.444444-22.755556 56.888889-56.888889 56.888889H853.333333c0 193.422222-153.6 347.022222-347.022222 347.022222s-347.022222-153.6-347.022222-347.022222h-28.444445c-28.444444 0-56.888889-22.755556-56.888888-56.888889V227.555556c0-28.444444 22.755556-56.888889 56.888888-56.888889h750.933334z' />
            </symbol>
            <symbol id='COIL' viewBox='0 0 1024 1024' width='24' height='24'>
              <path d='M853.333333 170.666667H170.666667c-34.133333 0-56.888889 22.755556-56.888889 56.888889v568.888888c0 34.133333 22.755556 56.888889 56.888889 56.888889h682.666666c34.133333 0 56.888889-22.755556 56.888889-56.888889V227.555556c0-34.133333-22.755556-56.888889-56.888889-56.888889z m-284.444444 56.888889v56.888888H455.111111V227.555556h113.777778z m170.666667 113.777777v341.333334H284.444444V341.333333h455.111112zM170.666667 227.555556h227.555555v56.888888H267.377778c-22.755556 0-39.822222 17.066667-39.822222 39.822223V398.222222H170.666667V227.555556z m0 227.555555h56.888889v113.777778H170.666667V455.111111z m0 341.333333v-170.666666h56.888889v73.955555c0 22.755556 17.066667 39.822222 39.822222 39.822223H398.222222v56.888888H170.666667z m284.444444 0v-56.888888h113.777778v56.888888H455.111111z m398.222222 0h-227.555555v-56.888888h130.844444c22.755556 0 39.822222-17.066667 39.822222-39.822223V625.777778h56.888889v170.666666z m0-227.555555h-56.888889V455.111111h56.888889v113.777778z m0-170.666667h-56.888889V324.266667c0-22.755556-17.066667-39.822222-39.822222-39.822223H625.777778V227.555556h227.555555v170.666666z' />
            </symbol>
            <symbol id='DEVICE-FOUR' viewBox='0 0 1024 1024' width='24' height='24'>
              <path d='M517.688889 204.8c39.822222 0 73.955556 22.755556 73.955555 45.511111s-34.133333 45.511111-73.955555 45.511111c-39.822222 0-73.955556-22.755556-73.955556-45.511111s34.133333-45.511111 73.955556-45.511111z m216.177778 91.022222c39.822222 0 73.955556 22.755556 73.955555 45.511111s-34.133333 45.511111-73.955555 45.511111-79.644444-17.066667-79.644445-45.511111 34.133333-45.511111 79.644445-45.511111z m-432.355556 0c39.822222 0 73.955556 22.755556 73.955556 45.511111s-28.444444 45.511111-73.955556 45.511111S227.555556 369.777778 227.555556 341.333333s34.133333-45.511111 73.955555-45.511111z m216.177778 62.577778c39.822222 0 73.955556 22.755556 73.955555 45.511111s-34.133333 45.511111-73.955555 45.511111c-39.822222 0-73.955556-22.755556-73.955556-45.511111s34.133333-45.511111 73.955556-45.511111z m0-182.044444c-216.177778 0-381.155556 79.644444-381.155556 170.666666s170.666667 170.666667 381.155556 170.666667 381.155556-79.644444 381.155555-170.666667-164.977778-170.666667-381.155555-170.666666z m0 398.222222c-159.288889 0-307.2-45.511111-381.155556-113.777778V512c0 85.333333 170.666667 170.666667 381.155556 170.666667 62.577778 0 125.155556-5.688889 176.355555-22.755556 5.688889 0 5.688889-5.688889 11.377778-5.688889 113.777778-28.444444 193.422222-85.333333 193.422222-147.911111V455.111111c-73.955556 73.955556-216.177778 119.466667-381.155555 119.466667z m381.155555 56.888889c-17.066667 17.066667-39.822222 28.444444-62.577777 39.822222v96.711111c39.822222-28.444444 62.577778-56.888889 62.577777-91.022222v-45.511111z m-119.466666 68.266666c-11.377778 5.688889-28.444444 11.377778-39.822222 11.377778v102.4c11.377778-5.688889 28.444444-11.377778 39.822222-17.066667v-96.711111zM136.533333 631.466667v51.2c0 85.333333 170.666667 170.666667 381.155556 170.666666 56.888889 0 113.777778-5.688889 159.288889-17.066666v-108.088889c-51.2 5.688889-102.4 11.377778-159.288889 11.377778-159.288889 0-307.2-39.822222-381.155556-108.088889zM517.688889 113.777778c238.933333 0 438.044444 91.022222 443.733333 221.866666V682.666667c0 68.266667-51.2 125.155556-130.844444 164.977777-5.688889 5.688889-17.066667 11.377778-22.755556 11.377778-79.644444 34.133333-182.044444 51.2-290.133333 51.2-244.622222 0-443.733333-96.711111-443.733333-227.555555V341.333333c0-130.844444 199.111111-227.555556 443.733333-227.555555z' />
            </symbol>
            <symbol id='COMPDETECTOR' viewBox='0 0 1024 1024' width='24' height='24'>
              <path d='M876.088889 369.777778c17.066667 0 34.133333 17.066667 34.133333 34.133333 0 210.488889-170.666667 375.466667-375.466666 375.466667-17.066667 0-34.133333-17.066667-34.133334-34.133334s17.066667-34.133333 34.133334-34.133333c170.666667 0 307.2-136.533333 307.2-307.2 0-17.066667 17.066667-34.133333 34.133333-34.133333zM290.133333 130.844444c11.377778 0 17.066667 5.688889 22.755556 11.377778l102.4 102.4 68.266667-68.266666c17.066667-11.377778 34.133333-17.066667 45.511111-5.688889l5.688889 5.688889c11.377778 11.377778 11.377778 34.133333 0 51.2L352.711111 409.6c-11.377778 11.377778-34.133333 11.377778-51.2 0-11.377778-11.377778-11.377778-34.133333 0-51.2l68.266667-68.266667-91.022222-91.022222H199.111111v642.844445h182.044445c17.066667 0 34.133333 17.066667 34.133333 34.133333s-17.066667 34.133333-34.133333 34.133333H164.977778c-17.066667 0-34.133333-17.066667-34.133334-34.133333V164.977778c0-17.066667 17.066667-34.133333 34.133334-34.133334h125.155555z M739.555556 335.644444c17.066667 0 34.133333 17.066667 34.133333 34.133334 0 153.6-125.155556 273.066667-273.066667 273.066666-17.066667 0-34.133333-17.066667-34.133333-34.133333s17.066667-34.133333 34.133333-34.133333c113.777778 0 204.8-91.022222 204.8-204.8 0-17.066667 11.377778-34.133333 34.133334-34.133334z M603.022222 301.511111c17.066667 0 34.133333 17.066667 34.133334 34.133333 0 96.711111-79.644444 170.666667-170.666667 170.666667-17.066667 0-34.133333-17.066667-34.133333-34.133333s17.066667-34.133333 34.133333-34.133334c56.888889 0 102.4-45.511111 102.4-102.4v-5.688888c0-11.377778 17.066667-28.444444 34.133333-28.444445z' />
            </symbol>
            <symbol id='RADAR' viewBox='0 0 1024 1024' width='24' height='24'>
              <path d='M256 347.022222c11.377778-5.688889 28.444444-5.688889 39.822222 0 11.377778 11.377778 11.377778 28.444444 0 39.822222C227.555556 455.111111 227.555556 563.2 295.822222 631.466667c11.377778 11.377778 11.377778 28.444444 0 39.822222-11.377778 11.377778-28.444444 11.377778-39.822222 0-91.022222-91.022222-91.022222-233.244444 0-324.266667z m483.555556 0c11.377778-11.377778 28.444444-11.377778 39.822222 0 91.022222 91.022222 91.022222 233.244444 0 324.266667-11.377778 11.377778-28.444444 11.377778-39.822222 0-11.377778-11.377778-11.377778-28.444444 0-39.822222 68.266667-68.266667 68.266667-176.355556 0-238.933334-11.377778-11.377778-11.377778-34.133333 0-45.511111zM620.088889 284.444444H420.977778v398.222223h199.111111V284.444444z m0-56.888888c34.133333 0 56.888889 22.755556 56.888889 56.888888v398.222223c0 34.133333-22.755556 56.888889-56.888889 56.888889H420.977778c-34.133333 0-56.888889-22.755556-56.888889-56.888889V284.444444c0-34.133333 22.755556-56.888889 56.888889-56.888888h199.111111zM176.355556 290.133333c5.688889-5.688889 28.444444-5.688889 39.822222 0 11.377778 11.377778 11.377778 34.133333 0 45.511111-102.4 96.711111-102.4 261.688889 0 358.4 11.377778 11.377778 11.377778 28.444444 0 39.822223-11.377778 11.377778-28.444444 11.377778-39.822222 0-125.155556-119.466667-125.155556-318.577778 0-443.733334z m654.222222 0c11.377778-11.377778 28.444444-11.377778 39.822222 0 119.466667 119.466667 119.466667 318.577778 0 443.733334-11.377778 11.377778-28.444444 11.377778-39.822222 0-11.377778-11.377778-11.377778-28.444444 0-39.822223 102.4-102.4 102.4-261.688889 0-364.088888-11.377778-5.688889-11.377778-28.444444 0-39.822223zM620.088889 796.444444c17.066667 0 28.444444 11.377778 28.444444 28.444445s-17.066667 28.444444-28.444444 28.444444H415.288889c-17.066667 0-28.444444-11.377778-28.444445-28.444444s11.377778-28.444444 28.444445-28.444445h204.8z' />
            </symbol>
            <symbol id='DEVEICE-BACKGROUND' width='60' height='60' viewBox='0 0 1024 1024'>
              <path d='M 0 0 L 480 0 L 480 480 L 0 480 L 0 0' />
            </symbol>
            <symbol id='CENTER-LIGHT' viewBox='0 0 1024 1024' width='24' height='24'>
              <path fill='#ffffff' d='M 773.689 273.067 H 267.378 c -108.089 0 -199.111 91.0222 -199.111 199.111 s 91.0222 199.111 199.111 199.111 h 506.311 c 108.089 0 199.111 -91.0222 199.111 -199.111 s -91.0222 -199.111 -199.111 -199.111 Z M 256 568.889 c -51.2 0 -91.0222 -39.8222 -91.0222 -91.0222 c 0 -51.2 39.8222 -91.0222 91.0222 -91.0222 s 91.0222 39.8222 91.0222 91.0222 c 0 51.2 -39.8222 91.0222 -91.0222 91.0222 Z m 273.067 0 c -51.2 0 -91.0222 -39.8222 -91.0222 -91.0222 c 0 -51.2 39.8222 -91.0222 91.0222 -91.0222 s 91.0222 39.8222 91.0222 91.0222 c 0 51.2 -39.8222 91.0222 -91.0222 91.0222 Z m 261.689 0 c -51.2 0 -91.0222 -39.8222 -91.0222 -91.0222 c 0 -51.2 39.8222 -91.0222 91.0222 -91.0222 c 51.2 0 91.0222 39.8222 91.0222 91.0222 c 0 51.2 -39.8222 91.0222 -91.0222 91.0222 Z' />
            </symbol>
            <symbol id='BIKE-SIGN' viewBox='0 0 1024 1024' width='60' height='24'>
              <path d='M643.42767 0.353926a28.224687 28.224687 0 0 1 31.887983 21.258656l0.403827 2.062406 7.196791 45.041235c2.163364 13.600347-5.913194 26.594953-19.080869 31.008215l-2.120097 0.634587-2.812373 0.53363-75.097569 10.312034a28.412178 28.412178 0 0 1-7.744843 0l-2.538347-0.47594-36.488736-8.480386 1.197061 4.903624c9.014016 38.854014 13.398433 78.832978 13.153252 119.936891l-0.144224 10.297612-0.11538 3.028709H1084.422175l19.686611-72.256352 0.028845-0.923035c0 0.187492-0.043267 0.230759-0.11538 0.144224l-0.403828-0.620164a20.494267 20.494267 0 0 0-1.298018-1.745114l-3.172934-3.69214-2.956597-1.326864c-39.373222-18.028032-60.934748-36.589694-63.718276-56.809934l-0.230759-2.249898-0.086534-2.264321c0-19.571231 17.508825-23.522976 64.511509-23.811424l61.309731-0.028845c2.538347 0 4.586331-0.230759 9.605335-1.298019l10.16781-2.26432c5.451677-1.240329 9.15824-2.01914 12.994606-2.653727 17.624204-2.91333 30.575542-1.153794 40.065498 8.278473 18.330903 18.201101 13.239787 41.334672-6.922764 64.122103-13.311899 15.071435-34.036924 29.940955-43.411501 31.844716l-1.384553 0.187491-1.932605 0.05769-14.307046 9.417844-21.114431 77.53496 128.936484 202.490854 0.591319-0.288449a297.981734 297.981734 0 0 1 117.340854-30.373628l7.730421-0.288448 7.355437-0.072112c164.660832 0 298.14038 132.628625 298.14038 296.23662S1568.366663 1024 1403.705831 1024c-150.772036 0-276.650966-111.629574-295.659723-257.844123l-0.605742-4.946892-0.374983-3.403693h-32.99851l-0.576897 2.3797a126.29718 126.29718 0 0 1-53.622578 73.424569l-3.836365 2.3797-1.90376 1.081682 9.893784 28.671782 1.269173-0.360561a21.244233 21.244233 0 0 1 23.349907 9.792827l0.923035 1.759536 0.764389 1.874915 6.028574 17.018462a20.984629 20.984629 0 0 1-11.047578 26.075746l-1.874916 0.764388-59.52135 20.81156a21.22981 21.22981 0 0 1-26.234392-10.989888l-0.764388-1.874915-6.028574-17.018462a20.984629 20.984629 0 0 1 11.047578-26.061323l1.874915-0.764389 3.144089-1.110527-11.004311-31.87356-5.192073 0.144224c-67.612331 0-122.879065-52.526474-126.758698-118.754251l-0.144224-3.692141-0.072112-3.720986c0-17.047307 3.418115-33.604251 9.893784-48.892023l2.033562-4.557486 1.701846-3.461382L516.668972 427.055808l-0.894191 2.812373a875.441229 875.441229 0 0 1-18.287635 49.872747l-5.148806 12.619622-3.33158 7.78811 0.403828 0.317294c64.194216 53.391819 103.293412 131.071003 106.653836 215.471037l0.173069 5.88435 0.05769 5.913194C596.295183 891.385797 462.801212 1024 298.14038 1024 133.479548 1024 0 891.371375 0 727.76338s133.479548-296.23662 298.14038-296.23662c39.142463 0 77.203244 7.499661 112.581454 21.835552l7.038144 2.956597 6.201643 2.797951 0.663431-1.557622c50.233308-122.893488 63.098112-234.912467 38.911704-336.316541l-1.716268-6.893919-0.360561-1.384553-1.745114 0.389405a28.267954 28.267954 0 0 1-30.878413-16.643479l-0.822078-2.163364-0.605742-2.019139-0.259603-1.139372-4.87478-27.316074a28.06604 28.06604 0 0 1 18.503972-31.33993l2.105674-0.663432 2.769106-0.576897L643.42767 0.339504zM1405.148074 504.792681c-30.863991 0-60.833791 6.201643-88.510426 18.028032l-4.586331 2.047985 118.941743 187.203083c11.912923 18.749153 0.288449 43.10863-21.34519 46.368098l-2.177786 0.245181-2.307588 0.086535H1182.638893l0.201914 1.471087c15.417573 107.519182 107.259579 189.308757 217.576711 191.601923l4.730556 0.043267c124.032859 0 224.58601-100.091633 224.58601-223.547595 0-123.455962-100.553151-223.547596-224.58601-223.547596zM295.659723 504.792681C172.203761 504.792681 72.112128 604.884314 72.112128 728.340277 72.112128 851.796239 172.203761 951.887872 295.659723 951.887872 419.115686 951.887872 519.207319 851.796239 519.207319 728.340277c0-59.564617-23.422019-115.379404-64.208639-156.80061l-1.341285-1.326864-1.773959 3.490227c-31.267819 60.285739-69.948764 122.374281-116.100525 186.308893l-9.316887 12.807114a38.219428 38.219428 0 0 1-61.612602-45.228726c50.117929-68.26134 91.207419-133.941066 123.311738-197.010333l2.350856-4.701711-5.451677-2.495079a222.451491 222.451491 0 0 0-82.727033-18.48955L295.659723 504.792681z m649.009149 173.069107a50.478489 50.478489 0 1 0 0 100.956978 50.478489 50.478489 0 0 0 0-100.956978z m178.116955-346.138213L1038.414637 631.421577a125.518369 125.518369 0 0 1 36.157021 60.069403l0.187492 0.793233h34.282105l0.620164-5.40841c9.576491-77.015752 50.045817-146.676068 111.918023-195.164262l4.326727-3.33158L1122.785827 331.723575z m133.695884 216.336383l-2.480657 2.278743c-37.930979 35.536856-63.242336 84.371189-70.886221 138.339906L1182.638893 692.284213h158.64668l-84.803862-144.224255zM1067.259488 288.456299H541.893794l-0.706699 5.408409a649.759115 649.759115 0 0 1-5.999729 35.075339l-1.557622 7.413127L888.940619 605.74966l1.326863-0.692276-12.90807-41.046224-2.610459 0.923036a21.388457 21.388457 0 0 1-26.407462-11.033156l-0.77881-1.874915-6.057419-17.104997a21.056741 21.056741 0 0 1 11.105267-26.16228l1.918183-0.764388 59.896333-20.912517a21.388457 21.388457 0 0 1 26.407461 11.033155l0.778811 1.874916 6.057419 17.104996a21.056741 21.056741 0 0 1-11.11969 26.176703l-1.701846 0.677854 14.739719 46.872883 4.932469 0.100956a128.79226 128.79226 0 0 1 26.10459 3.749831l2.826796 0.778811L1067.259488 288.456299z' />
            </symbol>
            <symbol viewBox='0 0 1024 1024' id='DELETE-DEVICES' width='16' height='16'>
              <path d='M61.44 382.016v-128h896v128zM541.44 382.016h128v448h-128z' fill='#737373' />
              <path d='M285.44 382.016v448h448v-448h-448z m-128-128h704v704h-704v-704z' fill='#737373' />
              <path d='M349.44 382.016h128v448h-128zM381.44 254.016h256v-64h-256v64z m384-192v320h-512v-320h512z' fill='#737373' />
            </symbol>
            <symbol id='BACKGROUNDRECT' viewBox='0 0 1024 1024' width='40' height='40'>
              <path d='M 0 0 L 480 0 L 480 480 L 0 480 L 0 0' />
            </symbol>
            {/* <symbol id='LOGO' width='75px' height='14px' viewBox='0 0 75 14'>
              <g stroke='none' strokeWidth='1' fill='none' fillRule='evenodd'>
                <g transform='translate(-2435.000000, -663.000000)'>
                  <g transform='translate(2435.000000, 663.000000)'>
                    <rect fill='#B0B0B0' fillRule='evenodd' x='0' y='0' width='75' height='14' rx='2' />
                    <path d='M2,1 L13,1 L13,1 L13,13 L2,13 C1.44771525,13 1,12.5522847 1,12 L1,2 C1,1.44771525 1.44771525,1 2,1 Z' fill='#FFFFFF' fillRule='evenodd' />
                    <polygon fillOpacity='0.2' fill='#545454' fillRule='evenodd' points='12 2 12 12 2 12' />
                    <polygon fillOpacity='0.2' fill='#545454' fillRule='evenodd' transform='translate(7.000000, 7.000000) scale(-1, 1) translate(-7.000000, -7.000000) ' points='12 2 12 12 2 12' />
                    <text fontFamily='Helvetica' fontSize='10' fontWeight='normal' fill='#FFFFFF'>
                      <tspan x='16' y='11'>D3TRAFFIC</tspan>
                    </text>
                  </g>
                </g>
              </g>
            </symbol> */}
            <symbol viewBox='0 0 1024 1024' id='EDITED-BTN' width='24' height='16'>
              <circle fill='rgba(216, 216, 216, 0.1)' cx='480' cy='480' r='240' />
              <path d='M 240 40 L 240 440 M 40 240 L 440 240' name='editedAddDirection' stroke='rgba(216, 216, 216, 0.8)' fill='rgba(216, 216, 216, 0.8)' cursor='pointer' />
            </symbol>
          </g>
          {/* 主要的绘制内容：车道，方向，设备等 */}
          <g className='svg-pan-zoom_viewport'>
            <g id='cb-aspects-draw'>
              {/* 定义一个分组所有的path和内容都加在这个元素下面 并绑定给了svg 直接svg.append('path')直接使用 */}
              {/* 人行横道的绘制，整个车道的灰色背景，道路分割线，停止线以及道路的轮廓都在这个分组下面 */}
              <g id='cb-trafficflow-group' />
              {/* 出口道和进口道有业务需要点击高亮，点击高亮内容在这个分组下面 */}
              <g id='cb-aspects-edited' />
              {/* 绘制所有的车道方向在这个分组下面 */}
              <g id='cb-aspects-dircections' />
              {/* 转向的阴影（分析工具有引用）渐变内容在这个分组下面 */}
              <g id='cb-aspects-turn-directions' />
              {/* 转向的图标比较小为了方便用户点击加了透明背景点击区域在这个bg分组下面 */}
              <g id='cb-aspects-dircections-bg' />
              {/* 设备绘制有的蓝色背景，选中的是红色背景在这个分组下面 */}
              <g id='cb-aspects-devices-bg' />
              {/* 绘制设备icon在这个分组下面 */}
              <g id='cb-aspects-devices' />
              {/* 绘制道路下面的名称标题是在这个分组下面 */}
              <g id='cb-aspects-road-name' />
              {/* 非机动车道的绘制时在这个分组下面 */}
              <g id='non-motor-vehicle-lane' />
              {/* 转向连接线 */}
              <g id='svg-connect-turn' />
              {/* 直行连接线 */}
              <g id='svg-connect-straight' />
              {/* 出口道 */}
              <g id='svg-road-outs' />
              {/* 进口道 */}
              <g id='svg-road-ins' />
              {/* 流量数值 */}
              <g id='svg-flow-num' />
              {/* 路名 */}
              <g id='svg-road-name' />
            </g>
          </g>
          {/* 增删车道按钮 */}
          {addBtnBool && this.addRoadBtnPlugin()}
          {/* 展示交叉路口信号灯 */}
          {
            showLight &&
              <InnerCenterLight
                coordinate={{ x: w * x + left - 25, y: h * y + top - 25 }}
                isEdited={isEdited}
                isSelect={isSelect}
                handleSelected={(e) => {
                  this.setState({
                    isSelect: true
                  })
                  this.props.centerCallback(false, true)
                }}
                handleEditCenterBtn={(e) => {
                  this.setState({
                    isEdited: false
                  })
                  this.props.centerCallback(false, isSelect)
                }}
              />
          }
          {/* 展示设备弹出框 */}
          {
            showAddModal &&
              <InnerAddDevice
                deviceClick={(e) => {
                  this.deviceClick(e)
                }}
                editRoadParams={editRoadParams}
                showModals={showAddModal}
                modalCoordinate={modalCoordinate}
              />
          }
          {/* 展示方向弹出框 */}
          {
            showAddDirectionsModal &&
              <InnerAddDirections
                handleSelectDirection={(e) => {
                  this.handleSelectDirectionClick(e)
                }}
                editRoadParams={editRoadParams}
                showModals={showAddDirectionsModal}
                modalCoordinate={modalCoordinate}
              />
          }
          {/* 显示说明功能的tip的信息 */}
          {showTip && this.showTipFunc()}
          {/* 展示防伪标识d3traffic的标志的 */}
          {/* <svg className='icon icon-logo' style={{ width: 75, height: 14 }} aria-hidden='true'>
            <use xlinkHref='#LOGO' transform={`translate(${w - 100} ${h - 30})`} />
          </svg> */}
          {/* 插件 */}
          {this.receivePlugin()}
        </svg>
      </div>
    )
  }

  componentDidMount () {
    const { data: propData, background, contentScale, showRoadName, isEdit, isEditOut, showCenterLight, centerColor, isDrawLaneDividers, isTurnDirections } = this.props
    const { w, h } = this.state
    const aspectData = propData || mock
    // 获取到最外层父级的元素的高度和宽度得到他们的高宽
    const width = document.getElementById('cb-flow-container') ? 383 : w
    const height = document.getElementById('cb-flow-container') ? 383 : h
    this.refDom = d3.select(this.refD3)
    // 初始化元素 svg转化成this.refDom.select('#cb-trafficflow-group') coord 将直角坐标变成svg坐标的内容coord.math2svg({x, y})得到svg坐标
    const { data, svg, coord } = this.drawSVG(aspectData, width, height)
    const originData = originDataInfos(aspectData) // 将数据按角度从小到大排列
    const streetInfos = caclStreetInfos(aspectData, width) // 将数据和主要的坐标点进行计算融合
    const flowData = this.handleFlowData(propData.flowData)
    this.initSvgPanZoom()
    this.setState({
      ...this.initialState,
      background,
      originData,
      flowData,
      data,
      center: aspectData.center,
      contentScale,
      svg,
      coord,
      showRoadName,
      isEdit,
      isEditOut,
      isDrawLaneDividers,
      isTurnDirections,
      w: width,
      h: height,
      isEdited: showCenterLight,
      isSelect: centerColor,
      streetInfos
    }, this.allFunc)
  }

  initSvgPanZoom = () => {
    const { zoomEnabled, defaultZoom } = this.props
    const svgZoomPanDom = this.refD3.getElementsByClassName('cb-flow-svg-zoomPan')
    if (svgZoomPanDom && svgZoomPanDom.length > 0) {
      this.svgPanZoom = svgPanZoom(svgZoomPanDom[0], {
        viewportSelector: '.svg-pan-zoom_viewport',
        panEnabled: true,
        zoomEnabled: zoomEnabled,
        minZoom: 0.5,
        maxZoom: 2,
        onZoom: this.handleChangeZoom,
        beforePan: this.getBeforePan
      })
      if (defaultZoom !== 1) {
        this.svgPanZoom.zoomBy(defaultZoom)
      }
    }
  }

  getBeforePan =(oldPan, newPan) => {
    if (this.props.getPanData && this.svgPanZoom) {
      this.props.getPanData(newPan)
    }
  }

  handleChangeZoom = () => {
    const { changeZoom } = this.props
    if (changeZoom && this.svgPanZoom) {
      const zoom = this.svgPanZoom.getZoom()
      this.props.changeZoom(zoom)
    }
  }

  // turnDirections () { // 注释没使用代码
  //   const { streetInfos, coord } = this.state
  //   // 遍历融合坐标点和车道信息的数组
  //   streetInfos.forEach((items, laneIndex) => {
  //     // laneIndex为道路的id， angle为每个道路的角度，laneWidth是每个道路中的车道的宽度
  //     const { angle, laneWidth, queueIns } = items
  //     // 通过start可以理解为比如0度的车道道路右边的最顶部的点， inflectionStart为车道道路右边靠近人行横道的点
  //     // end为道路左边的顶点，inflectionEnd是道路左边靠近人行横道的点
  //     const { start, end, ins, outs, inflectionStart, inflectionEnd } = this.concatCurPrePoint(laneIndex)
  //     // outs为出口道的数目ins为进口道的数组ins.length为进口道的数目，加起来是整个车道的数目
  //     // 出口道数目比上整个道路数目得到的比值 车道两边的两个点的连线inflectionStart, inflectionEnd splitPoint计算两个点直接的比例点，第三个参数为0.5为中点
  //     // 得到进口道和出口口道的连接点的比例为outs / (ins.length + outs) 从而得到相应的点 insStartPoint
  //     // insStartPoint1为车道顶部出口道和进口道的中的连接点
  //     const insStartPoint = coord.math2svg(splitPoint(inflectionStart, inflectionEnd, outs / (ins.length + outs)))
  //     const insStartPoint1 = coord.math2svg(splitPoint(start, end, outs / (ins.length + outs)))
  //     const insEnd = coord.math2svg(inflectionEnd)
  //     const insEnd1 = coord.math2svg(end)
  //     // 所有的进口道中choose为true的进口道
  //     // const insMsg = selectTableLaneRows.find(o => o.frid === obj.frid)

  //     const filtersIns = queueIns && queueIns.filter(items => items.choose)
  //     // 选中的进口道再一次遍历
  //     filtersIns && filtersIns.forEach((obj, insIndex) => {
  //       // trid 进口道Id
  //       const trid = obj.trid
  //       // 遍历所有的车道中的reverseRids是否存在选中进口道的trid方便找到这个选中的进口道是转向哪个出口道的
  //       const tridObj = streetInfos.find(item => item.reverseRids && Object.keys(item.reverseRids).indexOf(trid) > -1)
  //       if (!tridObj) return

  //       const { start: nextStart, end: nextEnd, ins: nextIns, outs: nextOuts, inflectionStart: tOutLineStart, inflectionEnd: nextInflectionEnd, angle: nextAngle } = this.concatCurPrePoint(tridObj.tabs)
  //       // nextInsStartPoint：得到转到哪个出口道的车道，然后找到其中的中点及nextOuts * 0.5 / (nextIns.length + nextOuts)
  //       // nextInsStartPoint1：找到出口道顶点两个点计算出口道顶点的中点的位置
  //       // inflectionLen：计算车道两边的点的宽度可以理解为道路宽度
  //       // inflectionSingleLen： 得到每个车道的宽度道路的宽度除以进口道数目和出口道的数目
  //       // laneLen得到顶点的出口道中点和靠近人行横道的中点的连线距离
  //       // laneWidthLen 设置转向箭头的宽
  //       // laneWidthPoint 设置转向小箭头的高
  //       // angleTip：转向小箭头的顶点的坐标
  //       // angleLeft： 小箭头右边的坐标
  //       // angleRight：小箭头的左边的左边
  //       // angleLeftPoint： 箭头和曲线左连接点的坐标
  //       // angleRightPoint：箭头和曲线右连接点的坐标
  //       const nextInsStartPoint = coord.math2svg(splitPoint(nextInflectionStart, nextInflectionEnd, nextOuts * 0.5 / (nextIns.length + nextOuts)))
  //       const nextInsStartPoint1 = coord.math2svg(splitPoint(nextStart, nextEnd, nextOuts * 0.5 / (nextIns.length + nextOuts)))
  //       const inflectionLen = pointLenth(nextInflectionStart, nextInflectionEnd)
  //       const inflectionSingleLen = nextIns.length + nextOuts === 0 ? laneWidth : inflectionLen / (nextIns.length + nextOuts)
  //       const laneLen = pointLenth(nextInsStartPoint1, nextInsStartPoint)

  //       const laneWidthLen = 10
  //       const laneWidthPoint = 4

  //       const angleTip = splitPoint(nextInsStartPoint1, nextInsStartPoint, (laneLen - 20) / laneLen)
  //       const angleLeft = coord.math2svg(splitPoint(nextInflectionStart, nextInflectionEnd, (inflectionSingleLen * nextOuts * 0.5 + laneWidthLen) / inflectionLen))
  //       const angleRight = coord.math2svg(splitPoint(nextInflectionStart, nextInflectionEnd, (inflectionSingleLen * nextOuts * 0.5 - laneWidthLen) / inflectionLen))

  //       const angleLeftPoint = coord.math2svg(splitPoint(nextInflectionStart, nextInflectionEnd, (inflectionSingleLen * nextOuts * 0.5 + laneWidthPoint) / inflectionLen))
  //       const angleRightPoint = coord.math2svg(splitPoint(nextInflectionStart, nextInflectionEnd, (inflectionSingleLen * nextOuts * 0.5 - laneWidthPoint) / inflectionLen))

  //       let curStartPoint = {} // 绘制曲线开始的连接控制点
  //       let curEndPoint = {} // 绘制曲线结束的连接控制点
  //       let d = ''// 主要的路径
  //       // obj.turnDur 1 左转， 2，直行，3，右转，4.掉头
  //       if (obj.turnDur === 4 || tridObj.tabs === laneIndex) { // 如果是掉头或者车道的下标和转向出口道的下标一致（说明为同一个车道）
  //         // backWidth： 得到 30 和车道的比例
  //         // angleLeftPointBack: 出口道的中点和向左偏移了30的距离的坐标点
  //         // angleRightPointBack： 出口道的中点和向右偏移了30的距离的坐标点
  //         // angleLeftPointBack1: 道路顶部出口道的中点和向左偏移了30的距离的坐标点
  //         // angleRightPointBack1 道路顶部出口道的中点和向右偏移了30的距离的坐标点
  //         // curStartPoint 顶部的点到人行横道出口道的点向外延申1.1倍得到贝塞尔内弯曲曲线的控制点
  //         // curEndPoint 顶部的点到人行横道出口道的点向外延申1.3倍得到贝塞尔外弯曲曲线的控制点
  //         const backWidth = 30 / pointLenth(nextInflectionStart, nextInflectionEnd)
  //         const angleLeftPointBack = coord.math2svg(splitPoint(nextInflectionStart, nextInflectionEnd, (nextOuts * 0.5 + backWidth) / (nextIns.length + nextOuts)))
  //         const angleRightPointBack = coord.math2svg(splitPoint(nextInflectionStart, nextInflectionEnd, (nextOuts * 0.5) / (nextIns.length + nextOuts)))

  //         const angleLeftPointBack1 = coord.math2svg(splitPoint(nextStart, nextEnd, (nextOuts * 0.5 + backWidth) / (nextIns.length + nextOuts)))
  //         const angleRightPointBack1 = coord.math2svg(splitPoint(nextStart, nextEnd, (nextOuts * 0.5) / (nextIns.length + nextOuts)))
  //         curStartPoint = splitPoint(angleLeftPointBack1, angleLeftPointBack, 1.1)
  //         curEndPoint = splitPoint(angleRightPointBack1, angleRightPointBack, 1.13)
  //       } else if (obj.turnDur === 2 || (Math.abs(angle.from - nextAngle.from) >= 160 && Math.abs(angle.from - nextAngle.from) <= 200)) { // 如果为直行或者两个道路角度相差在这个范围内
  //         // startAngleLeftPoint：通过进口道的分割点到道路右边的点的中点然后左偏移10px（pointLenth(insStartPoint, insEnd) * 0.5 - 10）得到了该控制点的起点
  //         // endAngleRightPoint： 通过进口道的分割点到道路右边的点的中点然后向右偏移10px得到了该控制点的起点
  //         // curStartPoint两个控制点的中点的连线的点
  //         // curEndPoint两个控制点中点作为控制点
  //         const startAngleLeftPoint = splitPoint(insStartPoint, insEnd, (pointLenth(insStartPoint, insEnd) * 0.5 - 10) / pointLenth(insStartPoint, insEnd))
  //         const endAngleRightPoint = splitPoint(insEnd, insStartPoint, (pointLenth(insStartPoint, insEnd) * 0.5 - 10) / pointLenth(insStartPoint, insEnd))
  //         curStartPoint = splitPoint(startAngleLeftPoint, angleLeftPoint, 0.5)
  //         curEndPoint = splitPoint(endAngleRightPoint, angleRightPoint, 0.5)
  //       } else if (obj.turnDur === 1) {
  //         const splitLinePoint = coord.math2svg(splitPoint(nextStart, nextEnd, nextOuts / (nextIns.length + nextOuts)))
  //         const splitSafeLinePoint = coord.math2svg(splitPoint(nextInflectionStart, nextInflectionEnd, nextOuts / (nextIns.length + nextOuts)))

  //         let jointX = 0
  //         let jointY = 0
  //         if (pointOblique(insStartPoint, insStartPoint1, angle.from) && pointOblique(splitLinePoint, splitSafeLinePoint, tridObj.angle.from)) {
  //           const { k: k1, b: b1 } = pointOblique(insStartPoint, insStartPoint1, angle.from)
  //           const { k: k2, b: b2 } = pointOblique(splitLinePoint, splitSafeLinePoint, tridObj.angle.from)
  //           jointX = (b2 - b1) / (k1 - k2)
  //           jointY = (b1 * k2 - b2 * k1) / (k2 - k1)
  //         } else if (!pointOblique(insStartPoint, insStartPoint1, angle.from) && pointOblique(splitLinePoint, splitSafeLinePoint, tridObj.angle.from)) {
  //           const { k: k1, b: b1 } = pointOblique(splitLinePoint, splitSafeLinePoint, tridObj.angle.from)
  //           jointX = insStartPoint.x
  //           jointY = k1 * insStartPoint.x + b1
  //         } else if (pointOblique(insStartPoint, insStartPoint1, angle.from) && !pointOblique(splitLinePoint, splitSafeLinePoint, tridObj.angle.from)) {
  //           const { k: k1, b: b1 } = pointOblique(insStartPoint, insStartPoint1, angle.from)
  //           jointX = insStartPoint.x
  //           jointY = k1 * splitLinePoint.x + b1
  //         }
  //         curStartPoint = { x: jointX, y: jointY }
  //         curEndPoint = splitPoint(splitSafeLinePoint, curStartPoint, 1.1)
  //       } else if (obj.turnDur === 3) {
  //         const splitLinePoint = coord.math2svg(splitPoint(nextStart, nextEnd, nextOuts / (nextIns.length + nextOuts)))
  //         const splitSafeLinePoint = coord.math2svg(splitPoint(nextInflectionStart, nextInflectionEnd, nextOuts / (nextIns.length + nextOuts)))

  //         let jointX = 0
  //         let jointY = 0
  //         if (pointOblique(insStartPoint, insStartPoint1, angle.from) && pointOblique(splitLinePoint, splitSafeLinePoint, tridObj.angle.from)) {
  //           const { k: k1, b: b1 } = pointOblique(insStartPoint, insStartPoint1, angle.from)
  //           const { k: k2, b: b2 } = pointOblique(splitLinePoint, splitSafeLinePoint, tridObj.angle.from)
  //           jointX = (b2 - b1) / (k1 - k2)
  //           jointY = (b1 * k2 - b2 * k1) / (k2 - k1)
  //         } else if (!pointOblique(insStartPoint, insStartPoint1, angle.from) && pointOblique(splitLinePoint, splitSafeLinePoint, tridObj.angle.from)) {
  //           const { k: k1, b: b1 } = pointOblique(splitLinePoint, splitSafeLinePoint, tridObj.angle.from)
  //           jointX = insStartPoint.x
  //           jointY = k1 * insStartPoint.x + b1
  //         } else if (pointOblique(insStartPoint, insStartPoint1, angle.from) && !pointOblique(splitLinePoint, splitSafeLinePoint, tridObj.angle.from)) {
  //           const { k: k1, b: b1 } = pointOblique(insStartPoint, insStartPoint1, angle.from)
  //           jointX = insStartPoint.x
  //           jointY = k1 * splitLinePoint.x + b1
  //         }
  //         curEndPoint = { x: jointX, y: jointY }
  //         curStartPoint = splitPoint(splitSafeLinePoint, curEndPoint, 1.1)
  //       }
  //       d = `M ${insStartPoint1.x} ${insStartPoint1.y} L ${insStartPoint.x} ${insStartPoint.y} Q
  //         ${curStartPoint.x} ${curStartPoint.y} ${angleLeftPoint.x} ${angleLeftPoint.y} L ${angleLeft.x} ${angleLeft.y} L
  //         ${angleTip.x} ${angleTip.y} L
  //         ${angleRight.x} ${angleRight.y} L ${angleRightPoint.x} ${angleRightPoint.y} Q
  //         ${curEndPoint.x} ${curEndPoint.y} ${insEnd.x} ${insEnd.y} L ${insEnd1.x} ${insEnd1.y} L
  //         ${insStartPoint1.x} ${insStartPoint1.y}`
  //       this.refDom.select('#cb-aspects-turn-directions')
  //         .append('path')
  //         .attr('fill-opacity', '0.5')
  //         .attr('fill', 'url(#Gradient1)')
  //         .attr('d', d)
  //     })
  //   })
  // }

  makeSVG (tag, attrs) {
    var el = document.createElementNS('http://www.w3.org/2000/svg', tag)
    for (var k in attrs) { el.setAttribute(k, attrs[k]) }
    return el
  }

  addMarker (newColor) {
    const defsEle = document.getElementById('markerArrow')
    if (!defsEle.querySelector(`#arrow-${newColor}`)) {
      const markerEle = this.makeSVG('marker', {
        id: `arrow-${newColor}`,
        markerUnits: 'strokeWidth',
        markerWidth: 12,
        markerHeight: 12,
        viewBox: '0 0 80 70',
        refX: '2',
        refY: '5',
        orient: 'auto'
      })
      const pathEle = this.makeSVG('path', {
        d: 'M0,0 L12,5 L0,10 L0,0',
        fill: `#${newColor}`
      })
      markerEle.appendChild(pathEle)
      defsEle.appendChild(markerEle)
    }
  }

  flowCount = (value) => {
    let flowValue = ''
    if (value < 100) {
      flowValue = 1.5
    } else if (value > 100 && value < 1000) {
      flowValue = value / 1000 * 12
    } else {
      flowValue = 12
    }
    return flowValue
  }

  handleColor = (colorList, key, flowData) => {
    let color = ''
    if (key) {
      color = colorList[key]
    } else {
      color = colorList[colorList.length - 1]
    }
    if (flowData === 0) {
      color = NO_DATA_COLOR
    }
    return color
  }

  handleGetFlowDataNum = (num) => {
    let Num = 0
    if (num) {
      Num = parseInt(num)
    }
    return Num
  }

  handleGetID = (frids) => {
    const bool = frids.find(frid => frid.turnDirNo === 2)
    return !!bool
  }

  getTurnNo = (filters, angle) => {
    const turnDirNo = filters && filters.map(({ frids }) => {
      return frids && frids.map(frid => {
        if (frid.tangle === angle) {
          return frid.turnDirNo
        }
      })
    })

    const arr = [...new Set(turnDirNo.flat())]
    return arr.filter(Boolean)
  }

  handleFlowData = (streets) => {
    let tabStreets = JSON.parse(JSON.stringify(streets))
    tabStreets = tabStreets.sort((a, b) => a.angle - b.angle)
    if (tabStreets.length === 2 &&
      Math.abs(tabStreets[0].angle - tabStreets[1].angle) > 160 && Math.abs(tabStreets[0].angle - tabStreets[1].angle) < 200) {
      tabStreets[1].angle = tabStreets[0].angle + 180
    }
    return tabStreets
  }

  getPathInfo = (path) => {
    const pathDom = document.createElementNS('http://www.w3.org/2000/svg', 'path')
    pathDom.setAttribute('d', `M ${path.replace(/;/g, ' L')}`)
    const pathLength = pathDom.getTotalLength()
    return { pathLength, pathDom }
  }

  isTrafficFlowShow () { // 核心逻辑
    const { coord, streetInfos, flowData } = this.state
    const conTurn = document.getElementById('svg-connect-turn')
    let filterArr = streetInfos.map((items, laneIndex) => {
      // laneIndex为道路的id， angle为每个道路的角度，laneWidth是每个道路中的车道的宽度
      const { inflectionStart, inflectionEnd, angle } = this.concatCurPrePoint(laneIndex)
      const obj = flowData && flowData.find(flow => flow.angle === items.angle.from)
      // 道路名称渲染
      const roadPoint = splitPoint(inflectionStart, inflectionEnd, 0.2)
      const add = coord.math2svg(normalMovePoint(angle.from - 90, { x: roadPoint.x, y: roadPoint.y }, -80, false))
      this.refDom.select('#svg-road-name').append('text')
        .attr('fill', '#666')
        .attr('font-size', 12)
        .text(items.name)
        .attr('transform', function (d, laneIndex) {
          return `translate(${add.x} ${add.y}) rotate(${angle.from - 180})`
        })
      return obj
    })
    filterArr = filterArr.filter(Boolean)
    filterArr.forEach((obj, laneIndex) => {
      const { ins, outs, inflectionStart, inflectionEnd, angle } = this.concatCurPrePoint(laneIndex)
      const insLine = splitPoint(inflectionStart, inflectionEnd, (ins.length / 2 + outs) / (outs + ins.length))
      const insLineEnd = coord.math2svg(normalMovePoint(angle.from - 90, { x: insLine.x, y: insLine.y }, -60, false))
      let insLineStart = coord.math2svg(insLine)
      if (obj) {
        const initialValue = null
        const sum = obj.frids && obj.frids.reduce((accumulator, currentValue) => { // 获取进口道流量总和数, 进口道累加
          return accumulator + currentValue.sumFlow
        }, initialValue)
        // 进口道渲染 和 转向到目标没有 关系
        if (ins && ins.length > 0) { // 进口到渲染
          this.refDom.select('#svg-road-ins').append('path')
            .attr('fill', 'none')
            .attr('stroke', this.handleColor(COLOR_LIST, laneIndex, this.handleGetFlowDataNum(sum)))
            .attr('stroke-width', obj.flowWidth)
            .attr('key', (d, i) => `rectlightborder${i}`)
            .attr('d', `M ${insLineStart.x} ${insLineStart.y} L ${insLineEnd.x} ${insLineEnd.y}`)
          const textPoint = splitPoint(insLineStart, insLineEnd, 0.25)
          this.refDom.select('#svg-flow-num').append('text')
            .attr('fill', '#666')
            .attr('font-size', 10)
            .text(this.handleGetFlowDataNum(sum))
            .attr('transform', function (d, laneIndex) {
              return `translate(${textPoint.x} ${textPoint.y}) rotate(${angle.from - 90})`
            })
        }
        obj.frids && obj.frids.forEach(flowItem => {
          // outs为出口道的数目ins为进口道的数组ins.length为进口道的数目，加起来是整个车道的数目
          // 出口道数目比上整个道路数目得到的比值 车道两边的两个点的连线inflectionStart, inflectionEnd splitPoint计算两个点直接的比例点，第三个参数为0.5为中点
          // 得到进口道和出口口道的连接点的比例为outs / (ins.length + outs) 从而得到相应的点 insStartPoint
          // insStartPoint1为车道顶部出口道和进口道的中的连接点
          const streetInfo = streetInfos.find(item => item.angle.from === flowItem.tangle) // streetInfo 表示目标信息
          if (streetInfo) {
            const {
              ins: nextIns, outs: nextOuts,
              inflectionStart: nextInflectionStart, inflectionEnd: nextInflectionEnd,
              angle: nextAngle
            } = this.concatCurPrePoint(streetInfo.tabs)
            const toLine = splitPoint(nextInflectionStart, nextInflectionEnd, (nextOuts / 2) / (nextOuts + nextIns.length))
            const insLineStart1 = coord.math2svg(normalMovePoint(nextAngle.from - 90, { x: insLine.x, y: insLine.y }, 0, false))
            // let toLineStart = coord.math2svg(normalMovePoint(nextAngle.from - 90, { x: toLine.x, y: toLine.y }, -5, false))
            let curStartPoint = {}
            const FlowDataNum = this.handleGetFlowDataNum(flowItem.sumFlow)
            const outFlowWidth = obj.outKeys[flowItem.tangle]
            const curOut = obj.outsFlowInfo[flowItem.tangle].filter((f) => { return f.from === angle.from })[0]
            insLineStart = coord.math2svg(normalMovePoint(angle.from, { x: insLine.x, y: insLine.y }, flowItem.offset - obj.flowWidth / 2, false))
            const toLineStart = coord.math2svg(normalMovePoint(nextAngle.from, { x: toLine.x, y: toLine.y }, outFlowWidth / 2 - curOut.offset, false))

            // turnDirNo 1 左转， 2，直行，3，右转，4.掉头
            if (flowItem.turnDirNo === 4) {
              const insAngleStart = coord.math2svg(normalMovePoint(angle.from - 90, { x: insLine.x, y: insLine.y }, 80, false))
              const outAngleStart = coord.math2svg(normalMovePoint(nextAngle.from - 90, { x: toLine.x, y: toLine.y }, 80, false))
              curStartPoint = splitPoint(insAngleStart, outAngleStart, 0.6)
              // 流量线的值
              const centerPoint = splitPoint(toLine, insLine, 0.5)
              const connectPoint = coord.math2svg(normalMovePoint(nextAngle.from - 180, { x: centerPoint.x, y: centerPoint.y }, 10, false))
              this.refDom.select('#svg-flow-num').append('text')
                .attr('fill', '#666')
                .attr('font-size', 10)
                .attr('text-shadow', '5px 5px 3px rgb(213,213,213)')
                .text(FlowDataNum)
                .attr('transform', function (d, laneIndex) {
                  return `translate(${connectPoint.x} ${connectPoint.y}) rotate(${angle.from + 180})`
                })
            } else if (flowItem.turnDirNo === 2) { // 直行
              curStartPoint = splitPoint(insLineStart1, toLineStart, 0.5)
              // 流量线的值
              const centerPoint = splitPoint(insLineStart1, toLineStart, 0.7)
              this.refDom.select('#svg-flow-num').append('text')
                .attr('fill', '#666')
                .attr('font-size', 10)
                .text(FlowDataNum)
                .attr('text-shadow', '0.1em 0.1em #333')
                .attr('transform', function (d, laneIndex) {
                  return `translate(${centerPoint.x} ${centerPoint.y}) rotate(${nextAngle.from + 90})`
                })
            } else if (flowItem.turnDirNo === 1 || flowItem.turnDirNo === 3) {
              const { a: a1, b: b1, c: c1 } = lineAnglePoint(angle.from, { x: insLine.x, y: insLine.y })
              const { a: a2, b: b2, c: c2 } = lineAnglePoint(nextAngle.from, { x: toLine.x, y: toLine.y })
              const joint = intersectionPoint2({ a1, b1, c1 }, { a2, b2, c2 })
              const jointStart = coord.math2svg(joint)
              curStartPoint = {
                x: jointStart.x,
                y: jointStart.y
              }
              // 流量线的值
              if (flowItem.turnDirNo === 1) {
                // const connectPoint = coord.math2svg(normalMovePoint(nextAngle.from - 90, { x: joint.x, y: joint.y }, 20, false))
                const { pathDom, pathLength } = this.getPathInfo(`${insLineStart.x} ${insLineStart.y} Q ${curStartPoint.x} ${curStartPoint.y} ${toLineStart.x} ${toLineStart.y}`)
                const { x, y } = pathDom.getPointAtLength(pathLength / 2)
                this.refDom.select('#svg-flow-num').append('text')
                  .attr('fill', '#666')
                  .attr('font-size', 10)
                  .text(FlowDataNum)
                  .attr('transform', function (d, laneIndex) {
                    return `translate(${x} ${y}) rotate(${nextAngle.from + 110})`
                  })
              } else if (flowItem.turnDirNo === 3) {
                const { pathDom, pathLength } = this.getPathInfo(`${insLineStart.x} ${insLineStart.y} Q ${curStartPoint.x} ${curStartPoint.y} ${toLineStart.x} ${toLineStart.y}`)
                const { x, y } = pathDom.getPointAtLength(pathLength / 2)
                this.refDom.select('#svg-flow-num').append('text')
                  .attr('fill', '#666')
                  .attr('font-size', 10)
                  .text(FlowDataNum)
                  .attr('transform', function (d, laneIndex) {
                    return `translate(${x} ${y}) rotate(${nextAngle.from - 110})`
                  })
              }
            }
            if (nextOuts && nextOuts > 0) {
              const toOutsInfo = filterArr.find(item => nextAngle.from === item.angle)
              const toOutsSum = toOutsInfo && Object.values(toOutsInfo.reverseRids) && Object.values(toOutsInfo.reverseRids)[0]
              const toLine = splitPoint(nextInflectionStart, nextInflectionEnd, (nextOuts / 2) / (nextOuts + nextIns.length))
              const tOutLineStart = coord.math2svg(normalMovePoint(nextAngle.from - 90, { x: toLine.x, y: toLine.y }, 0, false))
              const tOutLineEnd = coord.math2svg(normalMovePoint(nextAngle.from + 90, { x: toLine.x, y: toLine.y }, 50, false))
              if (!this.refDom.select(`.outs-${streetInfo.tabs}-checked`).node() && flowItem.turnDirNo === 2) {
                this.addMarker(this.handleColor(COLOR_LIST, laneIndex, this.handleGetFlowDataNum(toOutsSum)).replace('#', ''))
                this.refDom.select('#svg-road-outs').append('path')
                  .attr('fill', 'none')
                  .attr('class', `outs-${streetInfo.tabs}-checked`)
                  .attr('marker-end', `url(#arrow-${this.handleColor(COLOR_LIST, laneIndex).replace('#', '')})`)
                  .attr('stroke', this.handleColor(COLOR_LIST, laneIndex, this.handleGetFlowDataNum(toOutsSum)))
                  .attr('stroke-width', obj.outKeys[toOutsInfo.angle])
                  .attr('key', (d, i) => `rectlightborder${i}`)
                  .attr('d', `M ${tOutLineStart.x} ${tOutLineStart.y} L ${tOutLineEnd.x} ${tOutLineEnd.y}`)
                const outpoint = splitPoint(tOutLineStart, tOutLineEnd, 0.25)
                this.refDom.select('#svg-flow-num').append('text')
                  .attr('fill', '#666')
                  .attr('font-size', 10)
                  .text(this.handleGetFlowDataNum(toOutsSum))
                  .attr('transform', function (d, laneIndex) {
                    return `translate(${outpoint.x} ${outpoint.y}) rotate(${nextAngle.from - 90})`
                  })
              }
              const turnArr = this.getTurnNo(filterArr, nextAngle.from)
              if (turnArr.length > 0 && !turnArr.includes(2) && !this.refDom.select(`.outs-${streetInfo.tabs}-checked`).node()) {
                this.addMarker(this.handleColor(COLOR_LIST, streetInfo.tabs, this.handleGetFlowDataNum(toOutsSum)).replace('#', ''))
                const outLineEnd = coord.math2svg(normalMovePoint(nextAngle.from - 90, { x: toLine.x, y: toLine.y }, -60, false))
                const outLineStart = coord.math2svg(toLine)
                this.refDom.select('#svg-road-outs').append('path')
                  .attr('fill', 'none')
                  .attr('class', `outs-${streetInfo.tabs}-checked`)
                  .attr('marker-end', `url(#arrow-${this.handleColor(COLOR_LIST, streetInfo.tabs, this.handleGetFlowDataNum(toOutsSum)).replace('#', '')})`)
                  .attr('stroke', this.handleColor(COLOR_LIST, streetInfo.tabs, this.handleGetFlowDataNum(toOutsSum)))
                  .attr('stroke-width', obj.outKeys[toOutsInfo.angle])
                  .attr('key', (d, i) => `rectlightborder${i}`)
                  .attr('d', `M ${outLineStart.x} ${outLineStart.y} L ${outLineEnd.x} ${outLineEnd.y}`)
                const outpoint = splitPoint(outLineStart, outLineEnd, 0.25)
                this.refDom.select('#svg-flow-num').append('text')
                  .attr('fill', '#666')
                  .attr('font-size', 10)
                  .text(this.handleGetFlowDataNum(toOutsSum))
                  .attr('transform', function (d, laneIndex) {
                    return `translate(${outpoint.x} ${outpoint.y}) rotate(${angle.from - 90})`
                  })
              }
            }
            if (!conTurn.querySelector('svg-connect-turn')) { // 连接线渲染
              this.refDom.select('#svg-connect-turn').append('path')
                .attr('fill', 'none')
                .attr('stroke', this.handleColor(COLOR_LIST, laneIndex, this.handleGetFlowDataNum(flowItem.sumFlow)))
                // .attr('stroke-width', `${this.flowCount(flowItem.sumFlow)}`)
                .attr('stroke-width', flowItem.strokeWidth)
                .attr('key', (d, i) => `rectlightborder${i}`)
                .attr('d', `M ${insLineStart.x} ${insLineStart.y} Q ${curStartPoint.x} ${curStartPoint.y} ${toLineStart.x} ${toLineStart.y}`)
            }
          }
        })
      }
    })
  }

  handleSelectDirectionClick (e) {
    // 方向的弹出框中的方向选中点击的事件
    const { editRoadParams, streetInfos } = this.state
    let callbackType = '' // 操作类型 'delete', 'add', 'modify' // 删除， 增加， 修改
    let index = '' // 下标
    const changeStreetInfo = JSON.parse(JSON.stringify(streetInfos)) // 深拷贝下数据格式
    const [infoIndex, insIndex, deviceIndex] = editRoadParams.split('_')
    // infoIndex 道路下标，insIndex 进口道的下标，deviceIndex 设备的下标
    //
    const callTab = changeStreetInfo[infoIndex].ins[insIndex].tabs
    // 找到该道路下车道下的tabs值这个是以防合并车道时候下标变乱，用来记录哪个道路的下标 tabs 等同与infoIndex
    const insTab = changeStreetInfo[infoIndex].ins[insIndex].insTab
    if (!deviceIndex) { // 设备下标不存在证明为增加设备
      callbackType = 'add' // 具体的操作内容
      index = `${callTab}_${insTab}_${e}` // 返回道路下标车道下标，由于设备没有为新增的
      changeStreetInfo[infoIndex].ins[insIndex].directions = [e]
    } else if (e === 'DELETE') { // 删除选中的方向
      callbackType = 'delete'
      index = `${callTab}_${insTab}_${e}`
      changeStreetInfo[infoIndex].ins[insIndex].directions = []
    } else { // 修改方向的icon内容
      callbackType = 'modify'
      index = `${callTab}_${insTab}_${e}`
      changeStreetInfo[infoIndex].ins[insIndex].directions = [e]
    }
    // 重新改变的重新赋值给streetInfos, 并且将展示弹窗的控制设为false关闭弹窗showAddDirectionsModal
    this.setState({
      streetInfos: changeStreetInfo,
      showAddDirectionsModal: false
    }, () => {
      // 每次改变streetInfos需要再调用allFunc重新render
      this.allFunc()
    })
    // 点击之后给组件外部暴露的事件
    this.originDataCallBack({ option: callbackType, content: 'directions', index }, changeStreetInfo, callTab, e.split('_'))
  }

  deviceClick (e) {
    // 设备的弹窗的点击选择
    const { editRoadParams, streetInfos } = this.state
    let callbackType = '' // 操作类型 'delete', 'add', 'modify' // 删除， 增加， 修改
    let index = ''
    const changeStreetInfo = JSON.parse(JSON.stringify(streetInfos))
    const [infoIndex, insIndex, deviceIndex] = editRoadParams.split('_')
    const callTab = changeStreetInfo[infoIndex].ins[insIndex].tabs
    const insTab = changeStreetInfo[infoIndex].ins[insIndex].insTab
    if (e === 'DELETE-DEVICES') {
      changeStreetInfo[infoIndex].ins[insIndex].device.splice(deviceIndex, 1)
      index = `${callTab}_${insTab}_${deviceIndex}`
      callbackType = 'delete'
    } else if (!deviceIndex) {
      callbackType = 'add'
      index = `${callTab}_${insTab}_${changeStreetInfo[infoIndex].ins[insIndex].device.length}`
      changeStreetInfo[infoIndex].ins[insIndex].device.push({
        type: e
      })
    } else {
      callbackType = 'modify'
      index = `${callTab}_${insTab}_${deviceIndex}`
      changeStreetInfo[infoIndex].ins[insIndex].device[deviceIndex].type = e
    }
    this.setState({
      streetInfos: changeStreetInfo
    }, () => {
      this.allFunc()
    })
    this.originDataCallBack({ option: callbackType, content: 'device', index }, changeStreetInfo, callTab)
  }

  componentDidUpdate (prevProps) {
    const { data: propData, background, contentScale, width, height, isEdit, showRoadName, isEditOut, showCenterLight, centerColor, isDrawLaneDividers, isTurnDirections, newData } = this.props
    const { center, top, left } = this.state
    if (propData !== prevProps.data || prevProps.width !== width || prevProps.height !== height || prevProps.contentScale.x !== contentScale.x || prevProps.contentScale.y !== contentScale.y || isEdit !== prevProps.isEdit || isEditOut !== prevProps.isEditOut) {
      const w = document.getElementById('cb-flow-container') ? 383 : parseInt(width)
      const h = document.getElementById('cb-flow-container') ? 383 : parseInt(height)
      const aspectData = propData || mock
      const { data, svg } = this.drawSVG(aspectData, w, h)
      const { x, y } = center
      const coord = new SVGCoord({ x: 0, y: 0 }, { x: x * w + left, y: y * h + top })
      const originData = originDataInfos(aspectData)
      const streetInfos = caclStreetInfos(aspectData, w)
      const flowData = this.handleFlowData(propData.flowData)
      this.setState({
        ...this.initialState,
        showAddModal: this.state.showAddModal,
        showAddDirectionsModal: this.state.showAddDirectionsModal,
        modalCoordinate: this.state.modalCoordinate,
        editRoadParams: this.state.editRoadParams,
        background,
        data,
        svg,
        coord,
        w,
        h,
        contentScale,
        center,
        top,
        left,
        originData,
        isEdit,
        isEditOut,
        isDrawLaneDividers,
        isTurnDirections,
        streetInfos,
        flowData,
        showRoadName,
        isEdited: showCenterLight,
        isSelect: centerColor
      }, this.allFunc)
      newData && this.svgPanZoom.pan(newData)
    }
  }

  handleZoom = (newZoom, newData) => {
    this.svgPanZoom && this.svgPanZoom.zoomAtPoint(newZoom, newData)
  }

  clearAllSvg () {
    // 重新rander需要把之前插入的所有的svg元素清空
    this.refDom.select('#cb-aspects-edited').selectAll('*').remove()
    this.refDom.select('#cb-trafficflow-group').selectAll('*').remove()
    this.refDom.select('#cb-aspects-road-name').selectAll('*').remove()
    this.refDom.select('#non-motor-vehicle-lane').selectAll('*').remove()
    this.refDom.select('#cb-aspects-dircections').selectAll('*').remove()
    this.refDom.select('#cb-aspects-dircections-bg').selectAll('*').remove()
    this.refDom.select('#cb-aspects-devices').selectAll('*').remove()
    this.refDom.select('#cb-aspects-devices-bg').selectAll('*').remove()
    this.refDom.select('#cb-aspects-turn-directions').selectAll('*').remove()
    this.refDom.select('#svg-connect-turn').selectAll('*').remove()
    this.refDom.select('#svg-connect-straight').selectAll('*').remove()
    this.refDom.select('#svg-road-outs').selectAll('*').remove()
    this.refDom.select('#svg-road-ins').selectAll('*').remove()
    this.refDom.select('#svg-flow-num').selectAll('*').remove()
    this.refDom.select('#svg-road-name').selectAll('*').remove()
  }

  addLaneOption (index, option) { // 增加或删除车道按钮的点击事件
    const { streetInfos, w } = this.state
    const changeStreetInfo = JSON.parse(JSON.stringify(streetInfos))
    const { ins, outs, out } = changeStreetInfo[index]
    let resizePointInfo = ''
    if (option === 'insDelete') { // 减少进口道
      changeStreetInfo[index].ins.splice(0, 1)
      resizePointInfo = reSizeWidthInfo(changeStreetInfo, w)
    } else if (option === 'insAdd') { // 增加进口道
      ins.splice(0, 0, {
        directions: [],
        device: [],
        tabs: changeStreetInfo[index].tabs,
        rid: changeStreetInfo[index].ins.length > 0 ? changeStreetInfo[index].ins[0].rid : 0
      })
      resizePointInfo = reSizeWidthInfo(changeStreetInfo, w)
    } else if (option === 'outDelete') { // 减少出口道
      typeof changeStreetInfo[index].out === 'object' && changeStreetInfo[index].out.splice(0, 1)
      changeStreetInfo[index].outs = outs - 1 >= 0 ? outs - 1 : 0
      resizePointInfo = reSizeWidthInfo(changeStreetInfo, w)
    } else { // 增加出口道
      out && out.splice(0, 0, {
        tabs: changeStreetInfo[index].tabs,
        rid: changeStreetInfo[index].out.length > 0 ? changeStreetInfo[index].out[0].rid : 0
      })
      changeStreetInfo[index].outs = outs + 1
      resizePointInfo = reSizeWidthInfo(changeStreetInfo, w)
    }

    this.setState({
      streetInfos: resizePointInfo
    }, () => {
      this.allFunc()
      this.originDataCallBack({ option: option, content: 'lanebtn', index: changeStreetInfo[index].tabs }, resizePointInfo, changeStreetInfo[index].tabs)
    })
  }

  originDataCallBack (params, resizePointInfo, callTab) {
    const { originData } = this.state // 没有经过处理的props传入的元数据
    const streetsClone = JSON.parse(JSON.stringify(originData))
    // 遍历元数据 找到合并的进口道和出口道进行重新赋值使得他们在原来车道的数目进行变化
    originData.forEach((items, index) => {
      const goalData = resizePointInfo[callTab]
      if (goalData && index === callTab) {
        streetsClone[callTab].ins = goalData.ins.filter(item => item.tabs === callTab)
        streetsClone[callTab].outs = goalData.outs
      }
    })
    // 组件的回调函数  options操作内容， 操作元素， 操作的下标lane, ins, deviceIndex， 重组之后的元数据
    this.props.optionFunc(params.option, params.content, params.index, streetsClone)
  }

  showTipFunc () {
    // 展示tip显示内容 tipWords提示的内容
    const { tipWords, tipCoordinate: { x, y } } = this.state

    return (
      <foreignObject id='tip-msg' x={x - 50} y={y - 50} width={100} height={20}>
        <div className='tip-word'>{tipWords}</div>
      </foreignObject>
    )
  }

  addRoadBtnPlugin () {
    // 添加车道按钮的svg
    const { streetInfos, coord } = this.state
    const addList = streetInfos.map((items, laneIndex) => {
      // turnNo 车道总数量包括进口道和出口道
      // isOutBool 是否显示出口道
      // isInsBool 是否显示进口道
      // startOptions 在左边道路偏移20像素在安置增删车道的按钮
      // insLine2 在右边边道路偏移20像素在安置增删车道的按钮
      const { turnNo, angle, isOutBool, isInsBool, ins, outs } = items
      const { inflectionStart, inflectionEnd } = this.concatCurPrePoint(laneIndex)
      const newSaftStartLine = inflectionStart
      const newSaftEndLine = inflectionEnd
      const laneWidth = pointLenth(newSaftEndLine, newSaftStartLine)
      const startTurnNo = turnNo === 0 ? 1 : (laneWidth + 20) / laneWidth
      const endTurnNo = turnNo === 0 ? 0.7 : (laneWidth + 20) / laneWidth
      const startOptions = coord.math2svg(splitPoint(newSaftEndLine, newSaftStartLine, startTurnNo))
      const insLine2 = coord.math2svg(splitPoint(newSaftStartLine, newSaftEndLine, endTurnNo))
      const btnlist = []
      for (let i = 0; i < 4; i++) {
        if (!isOutBool && i === 2) {
          break
        }
        // 距离人行道300的位置点
        const startOption = 300
        if (isInsBool && (i === 0 || i === 1)) { // 如果为进口道
          const startPsi = 300
          const disY = i % 2 === 0 ? 32 : 0 // i % 2 === 0 为添加按钮进口道的 否则为删除进口道
          const type = i % 2 === 0 ? 'insAdd' : 'insDelete'
          // dx: dy: 通过这个300 加上30 或 0 的距离找到他们相应的x点和y左标点
          // x, y 通过之前的点准确找到具体的x，y坐标点
          // numb方向为0 或者180的道路不变其他的翻转90+保证每个按钮都是正方向的
          const dx = (startPsi + disY) * Math.sin(ang2rad(angle.from))
          const dy = (startPsi + disY) * Math.cos(ang2rad(angle.from))
          const x = insLine2.x + dx
          const y = insLine2.y - dy
          const numb = angle.from === 0 || angle.from === 180 ? angle.from : angle.from + 90
          ins.length > 0 && btnlist.push(
            <foreignObject key={`${laneIndex}_${i}`} id='cb-aspects-add-lane-button' transform={`translate(${x - 14} ${y - 14}) rotate(${numb} ${14} ${14})`} x={0} y={0} width={28} height={28}>
              <div
                className='lane-btn'
                onClick={() => {
                  this.addLaneOption(laneIndex, type)
                }}
                onMouseOver={() => {
                  this.setState({
                    showTip: true,
                    tipWords: `${i % 2 === 0 ? '增加进口道' : '减少进口道'}`,
                    tipCoordinate: { x: x, y: y }
                  })
                }}
                onMouseOut={() => {
                  this.setState({
                    showTip: false
                  })
                }}
              >
                <i className='ori' />
                {i % 2 === 0 && <i className='hro' />}
              </div>
            </foreignObject>)
          ins.length === 0 && i % 2 === 0 && btnlist.push(
            <foreignObject key={`${laneIndex}_${i}`} id='cb-aspects-add-lane-button' transform={`translate(${x - 14} ${y - 14}) rotate(${numb} ${14} ${14})`} x={0} y={0} width={28} height={28}>
              <div
                className='lane-btn'
                onClick={() => {
                  this.addLaneOption(laneIndex, type)
                }}
                onMouseOver={() => {
                  this.setState({
                    showTip: true,
                    tipWords: `${i % 2 === 0 ? '增加进口道' : '减少进口道'}`,
                    tipCoordinate: { x: x, y: y }
                  })
                }}
                onMouseOut={() => {
                  this.setState({
                    showTip: false
                  })
                }}
              >
                <i className='ori' />
                <i className='hro' />
              </div>
            </foreignObject>)
        }
        if (isOutBool && (i === 2 || i === 3)) {
          // 如果是出口道的增删车道
          const disY = i % 2 === 0 ? 32 : 0
          const type = i % 2 === 0 ? 'outAdd' : 'outDelete'
          const startLine = Math.abs(angle.to - angle.from) < 30 ? insLine2 : startOptions
          const dx = (startOption + disY) * Math.sin(ang2rad(angle.from))
          const dy = (startOption + disY) * Math.cos(ang2rad(angle.from))
          const x = startLine.x + dx
          const y = startLine.y - dy
          const numb = angle.from === 0 || angle.from === 180 ? angle.from : angle.from + 90
          outs > 0 && btnlist.push(
            <foreignObject key={`${laneIndex}_${i}`} id='cb-aspects-add-lane-out-button' transform={`translate(${x - 14} ${y - 14}) rotate(${numb} ${14} ${14})`} x={0} y={0} width={28} height={28}>
              <div
                className='lane-btn'
                onClick={() => {
                  this.addLaneOption(laneIndex, type)
                }}
                onMouseOver={() => {
                  this.setState({
                    showTip: true,
                    tipWords: `${i % 2 === 0 ? '增加出口道' : '减少出口道'}`,
                    tipCoordinate: { x: x, y: y }
                  })
                }}
                onMouseOut={() => {
                  this.setState({
                    showTip: false
                  })
                }}
              >
                <i className='ori' />
                {i % 2 === 0 && <i className='hro' />}
              </div>
            </foreignObject>)
          outs === 0 && i % 2 === 0 && btnlist.push(
            <foreignObject key={`${laneIndex}_${i}`} id='cb-aspects-add-lane-out-button' transform={`translate(${x - 14} ${y - 14}) rotate(${numb} ${14} ${14})`} x={0} y={0} width={28} height={28}>
              <div
                className='lane-btn'
                onClick={() => {
                  this.addLaneOption(laneIndex, type)
                }}
                onMouseOver={() => {
                  this.setState({
                    showTip: true,
                    tipWords: `${i % 2 === 0 ? '增加出口道' : '减少出口道'}`,
                    tipCoordinate: { x: x, y: y }
                  })
                }}
                onMouseOut={() => {
                  this.setState({
                    showTip: false
                  })
                }}
              >
                <i className='ori' />
                <i className='hro' />
              </div>
            </foreignObject>)
        }
      }
      return btnlist
    })
    return addList
  }

  guidesPointsData () {
    // 计算每个车道的分割内容，点坐标，方向信息等
    const { coord, streetInfos } = this.state
    const guidesPoints = streetInfos.reduce((p, c, i, a) => {
      const laneIndex = i
      const { ins, outs, angle, width, inflectionStart, inflectionEnd } = this.concatCurPrePoint(i)
      const { tabs, laneWidth, turnNo } = c
      const laneNum = ins.length + outs
      if (laneNum === 0) {
        return [
          ...p
        ]
      }
      const index = i
      const { x: xCurveStart, y: yCurveStart } = coord.math2svg(inflectionStart)
      const { x: xCurveEnd, y: yCurveEnd } = coord.math2svg(inflectionEnd)
      const stopPoints = segmentDividePoints({ x: xCurveStart, y: yCurveStart }, { x: xCurveEnd, y: yCurveEnd }, laneNum * 2)
      const laneMidPoints = stopPoints.reduce((p, c, i) => {
        let result
        if (i % 2 !== 0) {
          result = p
        } else {
          const laneIdx = Math.floor(i / 2)
          const isOut = laneIdx < outs
          const insIdx = laneIdx - outs
          const { directions } = insIdx >= 0 ? ins[insIdx] : { directions: [] }
          const editDirectionColor = insIdx >= 0 ? ins[insIdx].editDirectionColor : '#FF9000'
          const chooseDirection = insIdx >= 0 ? ins[insIdx].chooseDirection : false
          result = [...p, { ...c, turnNo, angle, isOut, directions, index, insIdx, inflectionStart, inflectionEnd, laneWidth, width, ins, outs, laneIdx, tabs, laneIndex, editDirectionColor, chooseDirection }]
        }
        return result
      }, [])
      return [
        ...p,
        ...laneMidPoints
      ]
    }, [])
    return guidesPoints
  }

  drawDevicePlugin () {
    // 画设备的内容
    const { streetInfos, coord } = this.state
    const self = this
    streetInfos.forEach((items, laneIndex) => {
      const { turnNo, angle, laneWidth } = items
      const { inflectionStart, inflectionEnd } = this.concatCurPrePoint(laneIndex)
      if (items.ins.length > 0) {
        items.ins.forEach((item, insIndex) => {
          const forbidBack = item.forbidBack
          const newJg = forbidBack ? 110 : 82
          const newJg1 = forbidBack ? 24 : 0
          const activeReviceInsIndex = items.ins.length - 1 - insIndex
          const insLine1 = coord.math2svg(splitPoint(inflectionEnd, inflectionStart, insIndex / turnNo))
          const insLine2 = coord.math2svg(splitPoint(inflectionEnd, inflectionStart, (insIndex + 1) / turnNo))
          const len = pointLenth(insLine1, insLine2)
          // 禁止掉头
          if (forbidBack) {
            this.refDom.select('#cb-aspects-devices-bg')
              .append('use')
              .attr('xlink:href', '#FORBID-BACK')
              .attr('fill', '#fad507')
              .attr('transform', function () {
                const bgLines = coord.math2svg(splitPoint(inflectionEnd, inflectionStart, (activeReviceInsIndex + 0.5) / turnNo))
                const dx = (78) * Math.sin(ang2rad(angle.from))
                const dy = (78) * Math.cos(ang2rad(angle.from))
                const x = bgLines.x + dx
                const y = bgLines.y - dy
                const height = this.getBBox().height / 2
                const width = this.getBBox().width / 2
                return `translate(${x - height} ${y - width}) rotate(${angle.from + 180} ${height} ${width})`
              })
          }
          if (!item.device) return
          if (item.device.length > 0) {
            item.device.forEach((obj, deviceIndex) => {
              const fillColor = obj.deviceColor ? '#ee4e4e' : '#1B98FF'
              const devicesAngle = obj.type === 'GANTRY' ? angle.from + 180 : angle.from
              const deviceWidth = obj.type === 'GANTRY' ? 20 : 23
              const deviceHeight = obj.type === 'GANTRY' ? 20 : 23
              const deviceGap = obj.type === 'GANTRY' ? 26 : 30
              const deviceMiddleScale = obj.type === 'GANTRY' ? 0.5 : 0.4
              const bgLines = coord.math2svg(splitPoint(inflectionEnd, inflectionStart, (activeReviceInsIndex + 0.5) / turnNo))
              const centerLines = coord.math2svg(splitPoint(inflectionEnd, inflectionStart, (activeReviceInsIndex + deviceMiddleScale) / turnNo))
              this.refDom.select('#cb-aspects-devices-bg')
                .append('use')
                .attr('width', 50)
                .attr('height', 50)
                .attr('xlink:href', '#DEVEICE-BACKGROUND')
                .attr('name', 'editedAddDevice')
                .attr('cursor', 'pointer')
                .attr('fill', fillColor)
                .attr('transform', function () {
                  const devicesOpt = deviceIndex * 29
                  const dx = (newJg + devicesOpt) * Math.sin(ang2rad(angle.from))
                  const dy = (newJg + devicesOpt) * Math.cos(ang2rad(angle.from))
                  const x = bgLines.x + dx
                  const y = bgLines.y - dy
                  const height = this.getBBox().height / 2
                  const width = this.getBBox().width / 2
                  return `translate(${x - height} ${y - width}) rotate(${angle.from} ${height} ${width})`
                })
                .on('mousedown', function (e) {
                  d3.event.stopPropagation()
                  d3.event.preventDefault()
                  const height = this.getBBox().height / 2
                  const width = this.getBBox().width / 2
                  const devicesOpt = deviceIndex * 29
                  const dx = (newJg + devicesOpt) * Math.sin(ang2rad(angle.from))
                  const dy = (newJg + devicesOpt) * Math.cos(ang2rad(angle.from))
                  const x = bgLines.x + dx
                  const y = bgLines.y - dy
                  if (d3.event.button === 2) {
                    const { x: x1, y: y1 } = self.borderTestPoint({ x: x - width, y: y - height }, 105, 170)
                    self.setState({
                      showAddModal: true,
                      editRoadParams: `${laneIndex}_${insIndex}_${deviceIndex}`,
                      modalCoordinate: {
                        x: x1,
                        y: y1
                      }
                    }, () => {
                      self.selectDevice(`${laneIndex}_${insIndex}_${deviceIndex}`)
                    })
                  } else {
                    self.setState({
                      showAddModal: false
                    }, () => {
                      self.selectDevice(`${laneIndex}_${insIndex}_${deviceIndex}`)
                    })
                  }
                })
                .on('contextmenu', function () {
                  d3.event.stopPropagation()
                  d3.event.preventDefault()
                  return false
                })
              this.refDom.select('#cb-aspects-devices')
                .append('use')
                .attr('name', 'editedAddDevice')
                .attr('width', deviceWidth)
                .attr('height', deviceHeight)
                .attr('xlink:href', `#${obj.type}`)
                .attr('transform', function () {
                  const devicesOpt = deviceIndex * deviceGap
                  const deviceStart = obj.type === 'GANTRY' && deviceIndex === 0 ? 80 : 86
                  const dx = (deviceStart + devicesOpt + newJg1) * Math.sin(ang2rad(angle.from))
                  const dy = (deviceStart + devicesOpt + newJg1) * Math.cos(ang2rad(angle.from))
                  const x = centerLines.x + dx
                  const y = centerLines.y - dy
                  const height = this.getBBox().height / 2
                  const width = this.getBBox().width / 2
                  return `translate(${x - height} ${y - width}) rotate(${devicesAngle} ${height} ${width})`
                })
                .attr('fill', '#ffffff')
                .attr('cursor', 'pointer')
                .on('mousedown', function (e) {
                  d3.event.stopPropagation()
                  d3.event.preventDefault()
                  const height = this.getBBox().height / 2
                  const width = this.getBBox().width / 2
                  const devicesOpt = deviceIndex * deviceGap
                  const deviceStart = obj.type === 'GANTRY' && deviceIndex === 0 ? 80 : 86
                  const dx = (deviceStart + devicesOpt + newJg1) * Math.sin(ang2rad(angle.from))
                  const dy = (deviceStart + devicesOpt + newJg1) * Math.cos(ang2rad(angle.from))
                  const x = centerLines.x + dx
                  const y = centerLines.y - dy
                  if (d3.event.button === 2) {
                    const { x: x1, y: y1 } = self.borderTestPoint({ x: x - width, y: y - height }, 105, 170)
                    self.setState({
                      showAddModal: true,
                      editRoadParams: `${laneIndex}_${insIndex}_${deviceIndex}`,
                      modalCoordinate: {
                        x: x1,
                        y: y1
                      }
                    }, () => {
                      self.selectDevice(`${laneIndex}_${insIndex}_${deviceIndex}`)
                    })
                  } else {
                    self.setState({
                      showAddModal: false
                    }, () => {
                      self.selectDevice(`${laneIndex}_${insIndex}_${deviceIndex}`)
                    })
                  }
                })
                .on('contextmenu', function () {
                  d3.event.stopPropagation()
                  d3.event.preventDefault()
                  return false
                })
              if (item.device.length - 1 === deviceIndex && item.device.length < 3) {
                const centerCircle = this.complateOptY(laneIndex, activeReviceInsIndex, 1, len * 0.5, (80 + newJg1 + (deviceIndex + 1) * 32))
                const laneBtnR = laneWidth <= 30 ? 10 : laneWidth / 2 - 10
                const pathLen = laneWidth <= 30 ? 5 : (laneWidth / 2 - 10) / 2
                this.refDom.select('#cb-aspects-devices')
                  .append('circle')
                  .attr('name', 'editedAddDevice')
                  .attr('fill', 'rgba(216, 216, 216, 0.1)')
                  .attr('cx', `${centerCircle.x}`)
                  .attr('cy', `${centerCircle.y}`)
                  .attr('r', laneBtnR)
                  .attr('cursor', 'pointer')
                  .on('click', () => {
                    const { x, y } = this.borderTestPoint(centerCircle, 105, 170)
                    this.setState({
                      showAddModal: true,
                      editRoadParams: `${laneIndex}_${insIndex}`,
                      modalCoordinate: {
                        x,
                        y
                      }
                    })
                  })
                  .on('mouseover', () => {
                    this.setState({
                      showTip: true,
                      tipWords: '添加设备按钮',
                      tipCoordinate: { x: centerCircle.x, y: centerCircle.y }
                    })
                  })
                  .on('mouseout', () => {
                    this.setState({
                      showTip: false
                    })
                  })
                this.refDom.select('#cb-aspects-devices')
                  .append('path')
                  .attr('name', 'editedAddDevice')
                  .attr('stroke', 'rgba(216, 216, 216, 0.8)')
                  .attr('fill', 'rgba(216, 216, 216, 0.8)')
                  .attr('cursor', 'pointer')
                  .attr('d', `M ${centerCircle.x + pathLen} ${centerCircle.y} L ${centerCircle.x - pathLen} ${centerCircle.y} M ${centerCircle.x} ${centerCircle.y + pathLen} L ${centerCircle.x} ${centerCircle.y - pathLen} `)
                  .on('click', () => {
                    const { x, y } = this.borderTestPoint(centerCircle, 105, 170)
                    this.setState({
                      showAddModal: true,
                      editRoadParams: `${laneIndex}_${insIndex}`,
                      modalCoordinate: {
                        x,
                        y
                      }
                    })
                  })
                  .on('mouseover', () => {
                    this.setState({
                      showTip: true,
                      tipWords: '添加设备按钮',
                      tipCoordinate: { x: centerCircle.x, y: centerCircle.y }
                    })
                  })
                  .on('mouseout', () => {
                    this.setState({
                      showTip: false
                    })
                  })
              }
            })
          } else {
            const centerCircle = this.complateOptY(laneIndex, activeReviceInsIndex, 1, len * 0.5, (80 + newJg1))
            const laneBtnR = laneWidth <= 30 ? 10 : laneWidth / 2 - 10
            const pathLen = laneWidth <= 30 ? 5 : (laneWidth / 2 - 10) / 2
            this.refDom.select('#cb-aspects-devices')
              .append('circle')
              .attr('name', 'editedAddDevice')
              .attr('fill', 'rgba(216, 216, 216, 0.1)')
              .attr('cx', `${centerCircle.x}`)
              .attr('cy', `${centerCircle.y}`)
              .attr('r', laneBtnR)
              .attr('cursor', 'pointer')
              .on('click', () => {
                const { x, y } = this.borderTestPoint(centerCircle, 105, 170)
                this.setState({
                  showAddModal: true,
                  editRoadParams: `${laneIndex}_${insIndex}`,
                  modalCoordinate: {
                    x,
                    y
                  }
                })
              })
              .on('mouseover', () => {
                this.setState({
                  showTip: true,
                  tipWords: '添加设备按钮',
                  tipCoordinate: { x: centerCircle.x, y: centerCircle.y }
                })
              })
              .on('mouseout', () => {
                this.setState({
                  showTip: false
                })
              })
            this.refDom.select('#cb-aspects-devices')
              .append('path')
              .attr('name', 'editedAddDevice')
              .attr('stroke', 'rgba(216, 216, 216, 0.8)')
              .attr('fill', 'rgba(216, 216, 216, 0.8)')
              .attr('cursor', 'pointer')
              .attr('d', `M ${centerCircle.x + pathLen} ${centerCircle.y} L ${centerCircle.x - pathLen} ${centerCircle.y} M ${centerCircle.x} ${centerCircle.y + pathLen} L ${centerCircle.x} ${centerCircle.y - pathLen} `)
              .on('click', () => {
                const { x, y } = this.borderTestPoint(centerCircle, 105, 170)
                this.setState({
                  showAddModal: true,
                  editRoadParams: `${laneIndex}_${insIndex}`,
                  modalCoordinate: {
                    x,
                    y
                  }
                })
              })
              .on('mouseover', () => {
                this.setState({
                  showTip: true,
                  tipWords: '添加设备按钮',
                  tipCoordinate: { x: centerCircle.x, y: centerCircle.y }
                })
              })
              .on('mouseout', () => {
                this.setState({
                  showTip: false
                })
              })
          }
        })
      }
    })
  }

  borderTestPoint (point, x, y) {
    // 计算弹窗是否超出渠化图整个内容然后重新计算点的位置
    const { w, h } = this.state
    let activeX = null
    let activeY = null
    if (point.x - x < 0) {
      activeX = x
    } else if (point.x - x > w) {
      activeX = w - x
    } else {
      activeX = point.x - x
    }
    if (point.y - y < 0) {
      activeY = y
    } else if (point.y - y > h) {
      activeY = h - y
    } else {
      activeY = point.y - y
    }

    return {
      x: activeX,
      y: activeY
    }
  }

  drawDirections () {
    // 绘制每个车道的转向的Icon
    const { coord, streetInfos } = this.state
    const guidesPoints = this.guidesPointsData()
    // guidesPoints = guidesPoints.filter(items => items.directions.length !== 0)
    this.refDom.select('#cb-aspects-dircections-bg')
      .selectAll('use')
      .data(guidesPoints)
      .enter()
      .append('use')
      .attr('xlink:href', '#DEVEICE-BACKGROUND')
      .attr('cursor', 'pointer')
      .attr('name', 'editedAddDirection')
      .attr('fill', 'transparent')
      .attr('transform', (v, i) => {
        const directions = v.directions && v.directions.length > 0 ? v.directions : []
        if (directions.length > 0 && !v.isOut) {
          const { x: x1, y: y1, angle, isOut } = v
          const s = 2
          const opt = 0.7
          const scales = 1
          const w = 40
          const h = 90
          const { x: x0, y: y0 } = { x: w * scales, y: isOut ? h * 0.43 : h * -0.08 }
          const { from } = angle
          const signAngle = from + (isOut ? 0 : 180)
          const result = `translate(${x1 - x0} ${y1 - y0}) rotate(${signAngle} ${x0} ${y0}) translate(${x0 * (1 - opt)} ${y0 * (1 - opt)}) scale(${s}) `
          return result
        } else if (directions.length === 0 && !v.isOut) {
          return ''
        } else {
          return ''
        }
      })
      .on('click', (v, i) => {
        const { x: x1, y: y1, editDirectionColor, insIdx, laneIndex } = v
        const callTab = streetInfos[laneIndex].ins[insIdx].tabs
        const insTab = streetInfos[laneIndex].ins[insIdx].insTab
        if (editDirectionColor) {
          streetInfos[laneIndex].ins[v.insIdx].chooseDirection = !streetInfos[laneIndex].ins[insIdx].chooseDirection
          this.setState({
            streetInfos
          }, this.allFunc)
          this.originDataCallBack({ option: 'editroadDirection', content: 'editroadDirection', index: `${callTab}_${insTab}` }, streetInfos, streetInfos[laneIndex].tabs)
        } else if (this.props.showDirectionsModal) {
          const w = 12
          const h = 90
          const { x: x0, y: y0 } = { x: w, y: h * -0.08 }
          const directions = v.directions && v.directions.length > 0 ? v.directions : []
          const { x, y } = this.borderTestPoint({ x: x1 - x0, y: y1 - y0 }, 105, 170)
          this.setState({
            showAddDirectionsModal: true,
            editRoadParams: `${v.laneIndex}_${v.insIdx}_${directions}`,
            modalCoordinate: {
              x,
              y
            }
          })
        }
      })
    this.refDom.select('#cb-aspects-dircections')
      .selectAll('use')
      .data(guidesPoints)
      .enter()
      .append('use')
      .attr('name', 'editedAddDirection')
      .attr('cursor', 'pointer')
      .attr('xlink:href', (v, i) => {
        const { directions } = v
        if (!directions) {
          return '#NONE'
        } else {
          const direList = v.isOut || directions.length === 0 ? ['NONE'] : directions.length > 2 ? ['STRAIGHT', 'RIGHT'] : directions
          const symbolStr = directions2Id(direList)
          return symbolStr
        }
      })
      .attr('transform', (v, i) => {
        const directions = v.directions && v.directions.length > 0 ? v.directions : []
        if (v.directions && directions.length > 0 && !v.isOut) {
          const { x: x1, y: y1, angle, isOut } = v
          const direList = directions.length > 2 ? ['STRAIGHT', 'RIGHT'] : directions
          const revist = JSON.parse(JSON.stringify(direList))
          const symbolStr = directions2Id(direList)
          const symbolStrRer = directions2Id(revist.reverse())
          const symbolWidth = this.refDom.select(symbolStr)._groups[0][0] !== null ? this.refDom.select(symbolStr).attr('width') / 2 : this.refDom.select(symbolStrRer).attr('width') / 2
          // const laneWidth = width / (ins.length + outs)
          const s = 2
          const opt = 1.8
          const scales = 1
          const w = symbolWidth
          const h = 90
          const { x: x0, y: y0 } = { x: w * scales, y: isOut ? h * 0.43 : h * -0.08 }
          const { from } = angle
          const signAngle = from + (isOut ? 0 : 180)
          const result = `translate(${x1 - x0} ${y1 - y0}) rotate(${signAngle} ${x0} ${y0}) translate(${x0 * (1 - opt)} ${y0 * (1 - opt)}) scale(${s}) `
          return result
        } else if (v.directions && directions.length === 0 && !v.isOut) {
          const { ins, laneWidth, laneIndex, x: x1, y: y1, insIdx, turnNo, inflectionEnd, inflectionStart } = v
          const insLine1 = coord.math2svg(splitPoint(inflectionStart, inflectionEnd, (ins.length - insIdx - 1) / turnNo))
          const insLine3 = coord.math2svg(splitPoint(inflectionStart, inflectionEnd, (ins.length - insIdx) / turnNo))
          const centerCircle = this.complateOptY(laneIndex, ins.length - insIdx - 1, 1, pointLenth(insLine1, insLine3) / 2, 50)
          const laneBtnR = laneWidth <= 30 ? 10 : laneWidth / 2 - 10
          const pathLen = laneWidth <= 30 ? 5 : (laneWidth / 2 - 10) / 2
          const w = 12
          const h = 90
          const { x: x0, y: y0 } = { x: w, y: h * -0.08 }
          this.refDom.select('#cb-aspects-dircections')
            .append('circle')
            .attr('name', 'editedAddDirection')
            .attr('fill', 'rgba(216, 216, 216, 0.1)')
            .attr('cx', `${centerCircle.x}`)
            .attr('cy', `${centerCircle.y}`)
            .attr('r', laneBtnR)
            .attr('cursor', 'pointer')
            .on('click', () => {
              const { x, y } = this.borderTestPoint({ x: x1 - x0, y: y1 - y0 }, 105, 170)
              this.setState({
                showAddDirectionsModal: true,
                editRoadParams: `${laneIndex}_${insIdx}`,
                modalCoordinate: {
                  x,
                  y
                }
              })
            })
            .on('mouseover', () => {
              this.setState({
                showTip: true,
                tipWords: '添加方向按钮',
                tipCoordinate: { x: centerCircle.x, y: centerCircle.y }
              })
            })
            .on('mouseout', () => {
              this.setState({
                showTip: false
              })
            })
          this.refDom.select('#cb-aspects-dircections')
            .append('path')
            .attr('name', 'editedAddDirection')
            .attr('stroke', 'rgba(216, 216, 216, 0.8)')
            .attr('fill', 'rgba(216, 216, 216, 0.8)')
            .attr('cursor', 'pointer')
            .attr('d', `M ${centerCircle.x + pathLen} ${centerCircle.y} L ${centerCircle.x - pathLen} ${centerCircle.y} M ${centerCircle.x} ${centerCircle.y + pathLen} L ${centerCircle.x} ${centerCircle.y - pathLen} `)
            .on('click', () => {
              d3.event.stopPropagation()
              d3.event.preventDefault()
              const { x, y } = this.borderTestPoint({ x: x1 - x0, y: y1 - y0 }, 105, 170)
              this.setState({
                showAddDirectionsModal: true,
                editRoadParams: `${laneIndex}_${insIdx}`,
                modalCoordinate: {
                  x,
                  y
                }
              })
            })
            .on('mouseover', () => {
              this.setState({
                showTip: true,
                tipWords: '添加方向按钮',
                tipCoordinate: { x: centerCircle.x, y: centerCircle.y }
              })
            })
            .on('mouseout', () => {
              this.setState({
                showTip: false
              })
            })
          return ''
        } else {
          return ''
        }
      })
      .attr('stroke', 'none')
      .attr('fill', (v, i) => {
        const editRoadColor = v.editDirectionColor ? v.editDirectionColor : '#FF9000'
        const isChoose = v.chooseDirection ? editRoadColor : '#fff'
        return isChoose
      })
  }

  selectDevice (e, types) {
    // 点击车道上的设备的回调函数
    const { streetInfos } = this.state
    const [laneIndex, insIndex, deviceIndexTab] = e.split('_')
    const callTab = streetInfos[laneIndex].ins[insIndex].tabs
    const insTab = streetInfos[laneIndex].ins[insIndex].insTab
    const changeStreetInfo = JSON.parse(JSON.stringify(streetInfos))
    const newChangeStreetInfo = changeStreetInfo.map((items, i) => {
      const insItems = items.ins.map((item, j) => {
        const deviceIndex = item.device.map((obj, x) => {
          return {
            ...obj,
            deviceColor: `${laneIndex}_${insIndex}_${deviceIndexTab}` === `${i}_${j}_${x}`
          }
        })
        return {
          ...item,
          device: deviceIndex
        }
      })
      return {
        ...items,
        ins: insItems
      }
    })
    this.setState({
      streetInfos: newChangeStreetInfo
    }, () => {
      this.allFunc()
    })
    this.originDataCallBack({ option: types || 'select', content: 'device', index: `${callTab}_${insTab}_${deviceIndexTab}` }, newChangeStreetInfo, callTab)
  }

  // 计算分割点

  complateOptY (laneIndex, insIndex, insScale, lenY, coordinateY) {
    const { streetInfos, coord } = this.state
    let streetInfosObj = {}
    if (!streetInfos[laneIndex]) {
      streetInfosObj = streetInfos.find((item, index) => item.tabs === laneIndex)
    } else {
      streetInfosObj = streetInfos[laneIndex]
    }
    // 选择到了某个道路
    // turnNo总数目车道， start右边的顶点的坐标点
    // inflectionEnd, inflectionStart人行横道基准线
    // vprev上一个道路信息
    //
    const { turnNo, start } = streetInfosObj
    const { inflectionEnd, inflectionStart } = this.concatCurPrePoint(laneIndex)
    const vprev = streetInfos[(laneIndex - 1 + streetInfos.length) % streetInfos.length]
    const { end } = vprev
    const insLine1 = coord.math2svg(splitPoint(inflectionEnd, inflectionStart, insIndex / turnNo))
    const insLine2 = coord.math2svg(splitPoint(inflectionEnd, inflectionStart, (insIndex + insScale) / turnNo))
    const insLineEnd1 = coord.math2svg(splitPoint(end, start, insIndex / turnNo))
    const insLineEnd2 = coord.math2svg(splitPoint(inflectionEnd, inflectionStart, (insIndex + 1) / turnNo))
    const len = pointLenth(insLine1, insLine2)
    const jgY1 = splitPoint(insLine1, insLine2, lenY / len)
    const jgY2 = splitPoint(insLineEnd1, insLineEnd2, lenY / len)
    const length = pointLenth(jgY1, jgY2)
    return splitPoint(jgY1, jgY2, coordinateY / length)
  }

  receivePlugin () {
    if (this.props.children) {
      const { data: propData, width, height } = this.props
      const { svg, coord, streetInfos, w, h, left, top } = this.state
      return React.Children.map(this.props.children, (plugin, index) => {
        return React.cloneElement(plugin, {
          propData: propData,
          width,
          height,
          svg,
          coord,
          streetInfos,
          index,
          w,
          h,
          left,
          top
        })
      }).sort((a, b) => {
        return a.props.zIndex > b.props.zIndex
      })
    }
  }

  allFunc () {
    const { isTurnDirections } = this.state
    this.clearAllSvg()
    // 绘制背景色
    // this.roadBg()
    // 绘制svg中心点
    // 绘制每条道路的虚线
    // isDrawLaneDividers && this.drawLaneDividers()
    // 绘制进口道的方向
    // 绘制停止线
    // this.drawCenterRect()
    // 绘制双黄分割线
    // this.drawsplitLine()
    // 绘制进口道高亮点击
    // isEdit && this.editRoad()
    // 绘制出口道的点击高亮
    // isEditOut && this.editOuts()
    // 绘制人行道
    // this.crossWalkRoad()
    // svg点击取消编辑状态
    // this.svgHandleFunc()
    // 绘制转向的内容
    // this.drawDirections()
    // 绘制分割线的内容
    // this.drawGreenDividers()
    // // 绘制设备的内容
    // this.drawDevices()
    // this.drawDevicePlugin()
    // 进口道转到出口道的渐变箭头
    // isTurnDirections && this.turnDirections()
    // 测试
    isTurnDirections && this.isTrafficFlowShow()
    // 非机动车道
    // this.nonMotorVehicleLane()
    // 车道的名称
    // showRoadName && this.roadName()

    // isShowStatus && this.drawCenterRectLine()
    // isQueue && this.queueLenBgData()
    // isFlow && this.flowBgDataWord()
  }

  drawCenterRectLine () {
    const { svg, coord, streetInfos } = this.state
    streetInfos.forEach((items, laneIndex) => {
      const { ins, outs, inflectionStart, inflectionEnd } = this.concatCurPrePoint(laneIndex)
      items.ins.forEach((obj, insIndex) => {
        const insLine1 = splitPoint(coord.math2svg(inflectionStart), coord.math2svg(inflectionEnd), (insIndex + outs) / (outs + ins.length))
        const insLine2 = splitPoint(coord.math2svg(inflectionStart), coord.math2svg(inflectionEnd), (insIndex + outs + 1) / (outs + ins.length))
        const color = obj.defaultColor ? (obj.lightColor ? obj.lightColor : '#FF0404') : (obj.directions.length === 1 && obj.directions.indexOf('RIGHT') > -1) ? 'transparent' : (obj.lightColor ? obj.lightColor : '#FF0404')
        svg.append('g')
          .attr('id', 'cb-aspects-street-ract-light-center')
          .append('path')
          .attr('d', `M ${insLine1.x} ${insLine1.y} L ${insLine2.x} ${insLine2.y}`)
          .attr('stroke', color)
          .attr('fill', 'none')
          .attr('stroke-width', 6)
          .attr('key', (d, i) => `rectlightborder${i}`)
      })
    })
  }

  flowBgDataWord () {
    const { coord, streetInfos } = this.state
    const self = this
    streetInfos.forEach((items, index) => {
      const { ins, outs, inflectionEnd, inflectionStart, angle } = this.concatCurPrePoint(index)

      ins.forEach((v, i) => {
        const insStartPoint1 = splitPoint(inflectionStart, inflectionEnd, (outs + i) / (ins.length + outs))
        const newStart1 = coord.math2svg(normalMovePoint(angle.from - 90, { x: insStartPoint1.x, y: insStartPoint1.y }, -120, false))
        const { flow, addFlow } = v
        if (flow !== null && flow !== undefined) {
          const flowLen = `${flow}(+${addFlow})`
          this.refDom.select('#cb-aspects-flow-word-num')
            .append('text')
            .attr('fill', '#ffffff')
            .attr('font-size', 12)
            .text(flowLen)
            .attr('transform', function (d, laneIndex) {
              self.createFlowBg(this.getBBox().width, this.getBBox().height, newStart1.x, newStart1.y, angle.from)
              return `translate(${newStart1.x} ${newStart1.y}) rotate(${angle.from - 90})`
            })
        }
      })
    })
  }

  createFlowBg (width, height, x, y, angle) {
    this.refDom.select('#cb-aspects-flow-word-bg')
      .append('rect')
      .attr('fill', '#000')
      .attr('width', `${width}`)
      .attr('height', `${height + 5}`)
      .attr('x', '0')
      .attr('y', `-${height - 1}`)
      .attr('fill-opacity', '0.5')
      .attr('transform', `translate(${x} ${y}) rotate(${angle - 90})`)
  }

  queueLenBgData () {
    const { coord, streetInfos, svg } = this.state
    svg.append('g')
      .attr('id', 'cb-flow-bg')
      .selectAll('path')
      .data(streetInfos)
      .enter()
      .append('path')
      .attr('d', (d, i) => {
        const { ins, outs, inflectionStart, inflectionEnd, angle, nextAngle: angleNext } = this.concatCurPrePoint(i)
        const flowData = ins.reduce((p, v, i) => {
          const { queueLen, addQueueLen, maxQueueLen } = v
          if (!queueLen || !addQueueLen || !maxQueueLen) {
            return p
          }
          const flowLen = 300 * (queueLen + addQueueLen) / maxQueueLen
          const insStartPoint1 = splitPoint(inflectionStart, inflectionEnd, (outs + i) / (ins.length + outs))
          const insStartPoint2 = splitPoint(inflectionStart, inflectionEnd, (outs + i + 1) / (ins.length + outs))
          const newStart1 = coord.math2svg(normalMovePoint(angle.from - 90, { x: insStartPoint1.x, y: insStartPoint1.y }, -flowLen, false))
          const newStart2 = coord.math2svg(normalMovePoint(angleNext.to - 90, { x: insStartPoint2.x, y: insStartPoint2.y }, -flowLen, false))
          return `${p} M ${newStart1.x} ${newStart1.y} L  ${newStart2.x} ${newStart2.y} L  ${coord.math2svg(insStartPoint2).x} ${coord.math2svg(insStartPoint2).y} L ${coord.math2svg(insStartPoint1).x} ${coord.math2svg(insStartPoint1).y}`
        }, '')
        return flowData
      })
      .attr('fill-opacity', '0.5')
      .attr('stroke', 'red')
      .attr('fill', 'red')
  }

  nonMotorVehicleLane () {
    const { coord, streetInfos } = this.state
    const self = this
    this.refDom.select('#non-motor-vehicle-lane')
      .selectAll('path')
      .data(streetInfos)
      .enter()
      .append('path')
      .attr('d', (d, i) => {
        const { isNonMotorVehicleOutLane, isNonMotorVehicleInsLane } = d
        const { inflectionStart, inflectionEnd, end, start, outs, ins } = this.concatCurPrePoint(i)
        let result = ''
        if (outs >= 2 && isNonMotorVehicleOutLane) {
          const outmotorVestartLine = coord.math2svg(splitPoint(inflectionStart, inflectionEnd, 1 / (outs + ins.length)))
          const outmotorVeendLine = coord.math2svg(splitPoint(start, end, 1 / (outs + ins.length)))
          result = ` M ${outmotorVestartLine.x} ${outmotorVestartLine.y} L ${outmotorVeendLine.x} ${outmotorVeendLine.y}`
        }
        if (ins.length >= 2 && isNonMotorVehicleInsLane) {
          const outmotorVestartLine = coord.math2svg(splitPoint(inflectionStart, inflectionEnd, (outs + ins.length - 1) / (outs + ins.length)))
          const outmotorVeendLine = coord.math2svg(splitPoint(start, end, (outs + ins.length - 1) / (outs + ins.length)))
          result = `${result} M ${outmotorVestartLine.x} ${outmotorVestartLine.y} L ${outmotorVeendLine.x} ${outmotorVeendLine.y}`
        }
        return result
      })
      .attr('stroke', '#fff')
      .attr('fill', 'none')
      .attr('stroke-width', 3)
    streetInfos.forEach((v, i) => {
      const { isNonMotorVehicleOutLane, isNonMotorVehicleInsLane } = v
      const { inflectionStart, inflectionEnd, outs, ins, angle } = self.concatCurPrePoint(i)
      let result = ''
      if (outs >= 2 && isNonMotorVehicleOutLane) {
        this.refDom.select('#non-motor-vehicle-lane')
          .append('use')
          .attr('xlink:href', '#BIKE-SIGN')
          .attr('fill', '#ffffff')
          .attr('transform', function (v, i) {
            const insmotorVestartLine = coord.math2svg(splitPoint(inflectionStart, inflectionEnd, -2 / pointLenth(inflectionStart, inflectionEnd)))
            const dx = (100) * Math.sin(ang2rad(angle.from))
            const dy = (100) * Math.cos(ang2rad(angle.from))
            const x = insmotorVestartLine.x + dx
            const y = insmotorVestartLine.y - dy
            const height = this.getBBox().height * 0.6 / 2
            const width = this.getBBox().width * 0.6 / 2
            result = `translate(${x - (width / 2)} ${y - (height / 2)}) rotate(${angle.from + 180} ${width / 2} ${height / 2}) scale(0.6)`
            return result
          })
      }
      if (ins.length >= 2 && isNonMotorVehicleInsLane) {
        this.refDom.select('#non-motor-vehicle-lane')
          .append('use')
          .attr('xlink:href', '#BIKE-SIGN')
          .attr('fill', '#ffffff')
          .attr('transform', function (v, i) {
            const insmotorVestartLine = coord.math2svg(splitPoint(inflectionStart, inflectionEnd, (pointLenth(inflectionStart, inflectionEnd) + 2) / pointLenth(inflectionStart, inflectionEnd)))
            const dx = (115) * Math.sin(ang2rad(angle.from))
            const dy = (115) * Math.cos(ang2rad(angle.from))
            const x = insmotorVestartLine.x + dx
            const y = insmotorVestartLine.y - dy
            const height = this.getBBox().height * 0.6 / 2
            const width = this.getBBox().width * 0.6 / 2
            result = `translate(${x - (width / 2)} ${y - (height / 2)}) rotate(${angle.from} ${width / 2} ${height / 2}) scale(0.6)`
            return result
          })
      }
    })
  }

  roadName () {
    const { coord, streetInfos } = this.state
    const self = this
    this.refDom.select('#cb-aspects-road-name')
      .selectAll('text')
      .data(streetInfos)
      .enter()
      .append('text')
      .attr('fill', '#666666')
      .attr('font-size', 12)
      .attr('cursor', 'pointer')
      .text((v, i) => {
        return v.name || ''
      })
      .attr('x', function () {
        return 0
      })
      .attr('y', function () {
        return this.getBBox().height
      })
      .attr('transform', function (d, laneIndex) {
        const { turnNo, angle } = d
        const { inflectionEnd, inflectionStart } = self.concatCurPrePoint(laneIndex)
        const endTurnNo = turnNo === 0 ? 0.4 : (turnNo + 0.4) / turnNo
        const insLine = coord.math2svg(splitPoint(inflectionStart, inflectionEnd, endTurnNo))
        const dx = 0 * Math.sin(ang2rad(angle.from))
        const dy = 0 * Math.cos(ang2rad(angle.from))
        const x = insLine.x + dx
        const y = insLine.y - dy
        return `translate(${x - this.getBBox().width / 2} ${y - this.getBBox().height / 2}) rotate(${angle.from + 90} ${this.getBBox().width / 2} ${this.getBBox().height / 2})`
      })
      .on('click', function (v, i) {
        self.props.roadNameCallback(v)
      })
  }

  uniteClickAndMove (dx, dy) {
    const { w, h, center } = this.state
    const { x, y } = center
    const coord = new SVGCoord({ x: 0, y: 0 }, { x: x * w + dx, y: y * h + dy })
    this.setState({
      coord,
      left: dx,
      top: dy
    }, () => {
      this.allFunc()
    })
  }

  svgHandleFunc () {
    const self = this
    this.refDom.select('#cb-flow-svg')
      .attr('cursor', 'grab')
      .on('mousedown', function () {
        self.isDrawer = false
        self.flag = true
        self.x = d3.event.clientX
        self.y = d3.event.clientY
        this.refDom.select('#cb-flow-svg')
          .attr('cursor', 'grabbing')
      })
      .on('mousemove', function () {
        if (
          self.isEnter &&
          self.flag &&
          d3.event.clientY - self.y !== 0 &&
          d3.event.clientX - self.x !== 0 &&
          d3.event.offsetX > 0 &&
          d3.event.offsetY < self.state.w
        ) {
          self.isDrawer = true
          const x = self.left + d3.event.clientX - self.x
          const y = self.top + d3.event.clientY - self.y
          self.uniteClickAndMove(x, y)
        }
      })
      .on('mouseup', function () {
        self.flag = false
        if (self.isDrawer) {
          self.isDrawer = false
          self.left = self.left + d3.event.clientX - self.x
          self.top = self.top + d3.event.clientY - self.y
        }
        this.refDom.select('#cb-flow-svg')
          .attr('cursor', 'grab')
      })
      .on('mouseenter', function () {
        self.isEnter = true
      })
      .on('mouseleave', function () {
        if (self.isDrawer) {
          self.isDrawer = false
          self.isEnter = false
          self.flag = false
          self.left = self.left + d3.event.clientX - self.x
          self.top = self.top + d3.event.clientY - self.y
        }
      })
      .on('click', function () {
        if (self.state.isSelect) {
          self.setState({
            isSelect: false
          })
        }
      })
  }

  crossWalkRoad () {
    const { crossWolkWidth, crossWolkHeight, crossJianJu } = this.props
    const { svg, coord, streetInfos } = this.state
    svg.append('g')
      .attr('id', 'cb-human-line')
      .selectAll('path')
      .data(streetInfos)
      .enter()
      .append('path')
      .attr('d', (d, i) => {
        const { inflectionStart, inflectionEnd, angle, nextAngle: angleNext } = this.concatCurPrePoint(i)
        const startDistance = crossWolkWidth || CROSS_WALK_WIDTH // 人行道的宽度
        const crosswalkLen = crossWolkHeight || startDistance * CROSS_SCALE_WALK_WIDTH // 人形道的长度

        const newNextJoint = normalMovePoint(angle.from - 90, { x: inflectionStart.x, y: inflectionStart.y }, crosswalkLen, false)
        const newJoint = normalMovePoint(angleNext.to - 90, { x: inflectionEnd.x, y: inflectionEnd.y }, crosswalkLen, false)
        const newSaftEnd = inflectionEnd
        const newSaftStart = inflectionStart
        const newSaftEndLine = splitPoint(newSaftEnd, newJoint, 0.1)
        const newSaftStartLine = splitPoint(newSaftStart, newNextJoint, 0.1)
        const fristLen = pointLenth(newSaftEndLine, newJoint)
        const secondLen = pointLenth(newSaftStartLine, newNextJoint)
        const lengScales = crosswalkLen / fristLen
        const { x: crosswolkStartx, y: crosswolkStarty } = splitPoint(newSaftEndLine, newJoint, 4 / fristLen)
        const { x: crosswolkJoinEndx, y: crosswolkJoinEndy } = splitPoint(newSaftEndLine, newJoint, lengScales)
        const { x: crosswolkEndx, y: crosswolkEndy } = splitPoint(newSaftStartLine, newNextJoint, 4 / secondLen)
        const { x: crosswolkJoinStartx, y: crosswolkJoinStarty } = splitPoint(newSaftStartLine, newNextJoint, lengScales)
        // new joint
        const jointConectLen = pointLenth({ x: crosswolkStartx, y: crosswolkStarty }, { x: crosswolkEndx, y: crosswolkEndy })
        const numb = Math.floor(jointConectLen / (startDistance))
        let result = ''
        for (let i = 0; i < numb + 1; i++) {
          const jianju = crossJianJu || 4
          if (i * jianju * startDistance < jointConectLen) {
            const end = i * jianju * startDistance + (startDistance) > jointConectLen ? jointConectLen : (i * startDistance * jianju) + (startDistance)
            const { x: x1, y: y1 } = coord.math2svg(splitPoint({ x: crosswolkStartx, y: crosswolkStarty }, { x: crosswolkEndx, y: crosswolkEndy }, (i * startDistance * jianju) / jointConectLen))
            const { x: x2, y: y2 } = coord.math2svg(splitPoint({ x: crosswolkStartx, y: crosswolkStarty }, { x: crosswolkEndx, y: crosswolkEndy }, end / jointConectLen))
            const { x: x3, y: y3 } = coord.math2svg(splitPoint({ x: crosswolkJoinEndx, y: crosswolkJoinEndy }, { x: crosswolkJoinStartx, y: crosswolkJoinStarty }, (i * startDistance * jianju) / jointConectLen))
            const { x: x4, y: y4 } = coord.math2svg(splitPoint({ x: crosswolkJoinEndx, y: crosswolkJoinEndy }, { x: crosswolkJoinStartx, y: crosswolkJoinStarty }, end / jointConectLen))
            result += `M ${x1} ${y1} L ${x3} ${y3} L ${x4} ${y4} L ${x2} ${y2} L ${x1} ${y1} `
          } else {
            break
          }
        }
        return result
      })
      .attr('stroke', '#b7b7b7')
      .attr('fill', '#b7b7b7')
  }

  roadBg () {
    const { svg, coord, streetInfos } = this.state
    const streetStr = streetInfos.reduce((p, d, i, arr) => {
      let [bodyStr, tailStr] = p
      const { safeStart, angle } = this.concatCurPrePoint(i)
      const { curveEnd, curveStart, start, end, joint, safeEnd } = d

      const { x: xCurveStart1, y: yCurveStart1 } = coord.math2svg(safeStart)

      const { x: xCurveEnd2, y: yCurveEnd2 } = coord.math2svg(safeEnd)

      const { x: xCurveStart, y: yCurveStart } = coord.math2svg(curveStart)
      const { x: xCurveEnd, y: yCurveEnd } = coord.math2svg(curveEnd)
      const { x: xStart, y: yStart } = coord.math2svg(start)
      const { x: xEnd, y: yEnd } = coord.math2svg(end)
      const { x: xJoint, y: yJoint } = coord.math2svg(joint)
      if (i === 0) {
        tailStr = `L ${xStart} ${yStart}`
      }

      if (Math.abs(angle.to - angle.from) > 170 && Math.abs(angle.to - angle.from) <= 190) {
        bodyStr = bodyStr.concat(`${i === 0 ? 'M' : 'L'} ${xStart} ${yStart}  L ${xCurveStart1} ${yCurveStart1} L ${xCurveEnd2} ${yCurveEnd2} L ${xEnd} ${yEnd}`)
      } else {
        bodyStr = bodyStr.concat(`${i === 0 ? 'M' : 'L'} ${xStart} ${yStart} ${`L ${xCurveStart} ${yCurveStart} Q ${xJoint} ${yJoint} ${xCurveEnd} ${yCurveEnd}`} L ${xEnd} ${yEnd}`)
      }

      return [bodyStr, tailStr]
    }, ['', ''])
    svg.append('g')
      .attr('id', 'draw-road-bg')
      .append('path')
      .attr('d', streetStr.join(''))
      .attr('fill', '#444446')
      .attr('key', (d, i) => `drawroadbg${i}`)
  }

  drawSVG (aspectData, w, h) {
    const { center } = aspectData
    const { x, y } = center
    const svg =
      this.refDom.select('#cb-trafficflow-group')
    const coord = new SVGCoord({ x: 0, y: 0 }, { x: x * w, y: y * h })
    return { data: aspectData, svg, coord }
  }

  editOuts () {
    const self = this
    const { state } = self
    const { coord, streetInfos } = state
    streetInfos.forEach((v, i) => {
      const { start, end, ins, outs, inflectionStart, inflectionEnd } = this.concatCurPrePoint(i)
      const { x: xCurveStart, y: yCurveStart } = coord.math2svg(inflectionStart)
      const { x: xCurveEnd, y: yCurveEnd } = coord.math2svg(inflectionEnd)
      const { x: xStart, y: yStart } = coord.math2svg(start)
      const { x: xEnd, y: yEnd } = coord.math2svg(end)
      const laneNum = ins.length + outs
      for (let x = 0; x < outs; x++) {
        const { x: splitSaftPointX, y: splitSafePointY } = splitPoint({ x: xCurveStart, y: yCurveStart }, { x: xCurveEnd, y: yCurveEnd }, x / laneNum)
        const { x: splitStartPointX, y: splitStartPointY } = splitPoint({ x: xStart, y: yStart }, { x: xEnd, y: yEnd }, x / laneNum)
        const { x: splitSaftPointX1, y: splitSafePointY1 } = splitPoint({ x: xCurveStart, y: yCurveStart }, { x: xCurveEnd, y: yCurveEnd }, (x + 1) / laneNum)
        const { x: splitStartPointX1, y: splitStartPointY1 } = splitPoint({ x: xStart, y: yStart }, { x: xEnd, y: yEnd }, (x + 1) / laneNum)
        const editRoadColor = streetInfos[i].editRoadColor ? streetInfos[i].editRoadColor : '#fff'
        const isChoose = streetInfos[i].chooseOut === x + 1 ? editRoadColor : 'transparent'
        this.refDom.select('#cb-aspects-edited').append('path')
          .attr('d', `M ${splitSaftPointX} ${splitSafePointY} L ${splitStartPointX} ${splitStartPointY} L ${splitStartPointX1} ${splitStartPointY1} L ${splitSaftPointX1} ${splitSafePointY1} L ${splitSaftPointX} ${splitSafePointY} `)
          .attr('stroke', 'none')
          .attr('fill', isChoose)
          .attr('key', (d, i) => `safe-start-line${i}`)
          .attr('fill-opacity', '0.7')
          .style('cursor', 'pointer')
      }
    })
  }

  editRoad () {
    const self = this
    const { state } = self
    const { coord, streetInfos } = state
    streetInfos.forEach((v, i) => {
      const { start, end, ins, outs, inflectionStart, inflectionEnd } = this.concatCurPrePoint(i)
      const { x: xCurveStart, y: yCurveStart } = coord.math2svg(inflectionStart)
      const { x: xCurveEnd, y: yCurveEnd } = coord.math2svg(inflectionEnd)
      const { x: xStart, y: yStart } = coord.math2svg(start)
      const { x: xEnd, y: yEnd } = coord.math2svg(end)
      const laneNum = ins.length + outs
      for (let x = outs; x < laneNum; x++) {
        const { x: splitSaftPointX, y: splitSafePointY } = splitPoint({ x: xCurveStart, y: yCurveStart }, { x: xCurveEnd, y: yCurveEnd }, x / laneNum)
        const { x: splitStartPointX, y: splitStartPointY } = splitPoint({ x: xStart, y: yStart }, { x: xEnd, y: yEnd }, x / laneNum)
        const { x: splitSaftPointX1, y: splitSafePointY1 } = splitPoint({ x: xCurveStart, y: yCurveStart }, { x: xCurveEnd, y: yCurveEnd }, (x + 1) / laneNum)
        const { x: splitStartPointX1, y: splitStartPointY1 } = splitPoint({ x: xStart, y: yStart }, { x: xEnd, y: yEnd }, (x + 1) / laneNum)
        const editRoadColor = streetInfos[i].ins[x - outs].editRoadColor ? streetInfos[i].ins[x - outs].editRoadColor : '#D8D8D8'
        const isChoose = streetInfos[i].ins[x - outs].choose ? editRoadColor : 'transparent'
        this.refDom.select('#cb-aspects-edited').append('path')
          .attr('d', `M ${splitSaftPointX} ${splitSafePointY} L ${splitStartPointX} ${splitStartPointY} L ${splitStartPointX1} ${splitStartPointY1} L ${splitSaftPointX1} ${splitSafePointY1} L ${splitSaftPointX} ${splitSafePointY} `)
          .attr('stroke', 'none')
          .attr('fill', isChoose)
          .attr('key', (d, i) => `safe-start-line${i}`)
          .attr('fill-opacity', '0.3')
          .style('cursor', 'pointer')
          .on('click', () => {
            const callTab = streetInfos[i].ins[x - outs].tabs
            const insTab = streetInfos[i].ins[x - outs].insTab
            streetInfos[i].ins[x - outs].choose = !streetInfos[i].ins[x - outs].choose
            self.setState({
              streetInfos
            }, this.allFunc)
            this.originDataCallBack({ option: 'editroad', content: 'editroad', index: `${callTab}_${insTab}` }, streetInfos, i)
          })
      }
    })
  }

  concatCurPrePoint (index) {
    const { crossWolkWidth, crossWolkHeight } = this.props
    const { streetInfos } = this.state
    const { angle, start, safeStart, ins, outs, width, inflectionStart, joint } = streetInfos[index]
    const len = streetInfos.length
    const vprev = streetInfos[(index - 1 + len) % len]
    const { safeEnd, end, inflectionEnd, joint: nextJoint, angle: nextAngle } = vprev
    const startInflectionStartLen = pointLenth(inflectionStart, start)
    const endInflectionEndLen = pointLenth(inflectionEnd, end)
    const startJointLen = pointLenth(joint, start)
    const endJointLen = pointLenth(nextJoint, end)
    let newInflectionStart = inflectionStart
    let newInflectionEnd = inflectionEnd
    const startDistance = crossWolkWidth || CROSS_WALK_WIDTH // 人行道的宽度
    const crosswalkLen = crossWolkHeight || startDistance * CROSS_SCALE_WALK_WIDTH // 人形道的长度
    if (startInflectionStartLen + crosswalkLen > startJointLen || endInflectionEndLen + crosswalkLen > endJointLen) {
      const diff = Math.abs(startJointLen) - Math.abs(endJointLen) > 0
        ? endJointLen : startJointLen
      newInflectionStart = normalMovePoint(angle.from - 90, start, diff - crosswalkLen - 30, false)
      newInflectionEnd = normalMovePoint(nextAngle.to - 90, end, diff - crosswalkLen - 30, false)
    }
    return {
      safeStart: safeStart,
      safeEnd: safeEnd,
      start,
      end,
      ins,
      outs,
      angle,
      nextAngle,
      inflectionStart: newInflectionStart,
      inflectionEnd: newInflectionEnd,
      width
    }
  }

  drawsplitLine () {
    const { svg, coord, streetInfos } = this.state
    svg.append('g')
      .attr('id', 'draw-split-line')
      .selectAll('path')
      .data(streetInfos)
      .enter()
      .append('path')
      .attr('d', (d, i) => {
        const { end, start, ins, outs, inflectionStart, inflectionEnd } = this.concatCurPrePoint(i)

        if (outs + ins.length && outs !== 0 && ins.length !== 0) {
          const scales = ins.length / (outs + ins.length)
          const { x: splitStartx, y: splitStarty } = splitPoint(end, start, scales)
          const { x: splitEndx, y: splitEndy } = splitPoint(inflectionEnd, inflectionStart, scales)
          const { x: xStart, y: yStart } = coord.math2svg({ x: splitStartx, y: splitStarty })
          const { x: xEnd, y: yEnd } = coord.math2svg({ x: splitEndx, y: splitEndy })
          const result = `M ${xStart} ${yStart} L ${xEnd} ${yEnd}`
          return result
        }
        return ''
      })
      .attr('stroke', '#fad507')
      .attr('fill', 'none')
      .attr('stroke-width', 2)
      .attr('key', (d, i) => `splitLine${i}`)
  }

  drawStreetBorders () {
    const { svg, coord, streetInfos } = this.state
    const borderPath = pipe(map(coord.math2svg.bind(coord)), streetBorderPath)
    svg.append('g')
      .attr('id', 'cb-aspects-street-borders')
      .selectAll('path')
      .data(streetInfos)
      .enter()
      .append('path')
      .attr('d', borderPath)
      .attr('stroke', '#ffffff')
      .attr('fill', 'none')
      .attr('key', (d, i) => `border${i}`)
  }

  drawLaneDividers () {
    const { svg, coord, streetInfos } = this.state
    svg.append('g')
      .attr('id', 'cb-aspects-curve-start-lines')
      .selectAll('path')
      .data(streetInfos)
      .enter()
      .append('path')
      .attr('d', (v, i) => {
        const { start, end, ins, outs, inflectionStart, inflectionEnd } = this.concatCurPrePoint(i)
        const { x: xCurveStart, y: yCurveStart } = coord.math2svg(inflectionStart)
        const { x: xCurveEnd, y: yCurveEnd } = coord.math2svg(inflectionEnd)
        const { x: xStart, y: yStart } = coord.math2svg(start)
        const { x: xEnd, y: yEnd } = coord.math2svg(end)
        const laneNum = ins.length + outs
        if (laneNum === 0) {
          return ''
        }
        const stopPoints = segmentDividePoints({ x: xCurveStart, y: yCurveStart }, { x: xCurveEnd, y: yCurveEnd }, laneNum)
        const terminalPoints = segmentDividePoints({ x: xStart, y: yStart }, { x: xEnd, y: yEnd }, laneNum)
        const result = zip(stopPoints, terminalPoints).reduce((p, v, i) => {
          const { x: x0, y: y0 } = v[0]
          const { x: xCenter, y: yCenter } = splitPoint(v[0], v[1], 115 / pointLenth(v[0], v[1]))
          const splitV = splitPoint(v[1], v[0], 0.5)
          const insLen = pointLenth(v[0], splitV)
          const num = insLen / 11
          let strs = i < outs ? '' : `M ${x0} ${y0} L ${xCenter} ${yCenter} `

          for (let x = 0; x < num - 1; x++) {
            if (x % 2 === 0) {
              const { x: splitStartx, y: splitStarty } = splitPoint(v[0], v[1], x * 11 / insLen)
              const { x: splitStartx1, y: splitStarty1 } = splitPoint(v[0], v[1], (x + 1) * 11 / insLen)
              strs += `M ${splitStartx} ${splitStarty} L ${splitStartx1} ${splitStarty1} `
            }
          }
          return p.concat(strs)
        }, '')
        return result
      })
      .attr('stroke', '#ffffff')
      .attr('stroke-width', 2)
      .attr('fill', 'none')
      .attr('key', (d, i) => `curve-start-line${i}`)
  }

  drawGreenDividers () {
    const { svg, coord, streetInfos } = this.state
    svg.append('g')
      .attr('id', 'cb-aspects-curve-start-green-lines')
      .selectAll('path')
      .data(streetInfos)
      .enter()
      .append('path')
      .attr('d', (v, i) => {
        const { out } = v
        const { start, end, ins, outs, inflectionEnd, inflectionStart } = this.concatCurPrePoint(i)
        const { x: xCurveStart, y: yCurveStart } = coord.math2svg(inflectionStart)
        const { x: xCurveEnd, y: yCurveEnd } = coord.math2svg(inflectionEnd)
        const { x: xStart, y: yStart } = coord.math2svg(start)
        const { x: xEnd, y: yEnd } = coord.math2svg(end)
        const laneNum = ins.length + outs
        let insRid = ''
        let outRid = ''
        let outsNum = 0
        const ridArr = []
        ins.forEach((items, index) => {
          if (index === 0) {
            insRid = items.rid
          }
          if (items.rid !== insRid) {
            insRid = items.rid
            ridArr.push(index + outs - 1)
          }
        })
        out && typeof out === 'object' && out.forEach((items, index) => {
          if (index === 0) {
            outRid = items.rid
          }
          if (items.rid !== outRid) {
            outRid = items.rid
            ridArr.push(outsNum - 1)
          }
          outsNum = outsNum + items.out
        })
        if (laneNum === 0) {
          return ''
        }
        const stopPoints = segmentDividePoints({ x: xCurveStart, y: yCurveStart }, { x: xCurveEnd, y: yCurveEnd }, laneNum)
        const terminalPoints = segmentDividePoints({ x: xStart, y: yStart }, { x: xEnd, y: yEnd }, laneNum)
        const result = zip(stopPoints, terminalPoints).reduce((p, v, i) => {
          if (ridArr && ridArr.indexOf(i) > -1) {
            const { x: x0, y: y0 } = v[0]
            const { x: x1, y: y1 } = v[1]
            const strs = `M ${x0} ${y0} L ${x1} ${y1} `
            return p.concat(strs)
          } else {
            return p
          }
        }, '')
        return result
      })
      .attr('fill', 'none')
      .attr('stroke-width', 5)
      .attr('stroke', '#4E7C39')
      .attr('key', (d, i) => `curve-start-line${i}`)
  }

  drawCenterRect () {
    const { svg, coord, streetInfos } = this.state
    svg.append('g')
      .attr('id', 'cb-aspects-street-ract-center')
      .selectAll('path')
      .data(streetInfos)
      .enter()
      .append('path')
      .attr('d', (d, i) => {
        const { ins, outs, inflectionStart, inflectionEnd } = this.concatCurPrePoint(i)

        const { x: xJoint, y: yJoint } = inflectionEnd
        const { x: xNextJoint, y: yNextJoint } = inflectionStart
        if (outs + ins.length) {
          const scales = ins.length / (outs + ins.length)
          const { x: xNextJoint$, y: yNextJoint$ } = coord.math2svg({ x: xNextJoint, y: yNextJoint })
          const { x: xJoint$, y: yJoint$ } = coord.math2svg({ x: xJoint, y: yJoint })
          const { x: xNextJoint$$, y: yNextJoint$$ } = splitPoint({ x: xJoint$, y: yJoint$ }, { x: xNextJoint$, y: yNextJoint$ }, scales)
          const result = `M ${xJoint$} ${yJoint$} L ${xNextJoint$$} ${yNextJoint$$}`
          return result
        } else {
          return ''
        }
      })
      .attr('stroke', '#ffffff')
      .attr('fill', 'none')
      .attr('stroke-width', 2)
      .attr('key', (d, i) => `rectborder${i}`)
  }
}

TrafficFlow.defaultProps = {
  centerCallback: (e, v) => { },
  optionFunc: () => { },
  addBtnBool: true,
  showCenterLight: true,
  centerColor: false,
  prevModalWidth: 180,
  contentScale: { x: 1, y: 1 },
  isDrawLaneDividers: true,
  showLight: false,
  isEdit: true,
  showDirectionsModal: true,
  isEditOut: false,
  crossWolkWidth: CROSS_WALK_WIDTH,
  crossWolkHeight: CROSS_SCALE_WALK_WIDTH,
  crossJianJu: 4,
  showRoadName: false,
  zoomEnabled: true,
  defaultZoom: 1,
  roadNameCallback: () => { },
  isTurnDirections: true
}

TrafficFlow.Plugin = Plugin
TrafficFlow.CenterLight = CenterLight
TrafficFlow.AddDevice = AddDevice
TrafficFlow.AddDirection = AddDirection
TrafficFlow.propTypes = {
  width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  data: PropTypes.oneOfType([PropTypes.object]), // 渲染道路数据
  isEdit: PropTypes.oneOfType([PropTypes.bool]), // 是否开启编辑道路模式
  contentScale: PropTypes.oneOfType([PropTypes.object]),
  background: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  centerCallback: PropTypes.oneOfType([PropTypes.func]),
  optionFunc: PropTypes.oneOfType([PropTypes.func]),
  addBtnBool: PropTypes.oneOfType([PropTypes.bool]),
  showCenterLight: PropTypes.oneOfType([PropTypes.bool]),
  centerColor: PropTypes.oneOfType([PropTypes.bool]),
  prevModalWidth: PropTypes.oneOfType([PropTypes.number]),
  isDrawLaneDividers: PropTypes.oneOfType([PropTypes.bool]), // 是否显示分割线
  crossWolkWidth: PropTypes.oneOfType([PropTypes.number]),
  crossWolkHeight: PropTypes.oneOfType([PropTypes.number]),
  crossJianJu: PropTypes.oneOfType([PropTypes.number]),
  showLight: PropTypes.oneOfType([PropTypes.bool]), // 是否显示信号灯
  showDirectionsModal: PropTypes.oneOfType([PropTypes.bool]),
  isEditOut: PropTypes.oneOfType([PropTypes.bool]), // 是否可以编辑出口道
  roadNameCallback: PropTypes.oneOfType([PropTypes.func]) // 点击姓名的回调函数
}
export default TrafficFlow
